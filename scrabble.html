<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <title>Scrabble - Nino's Webhome</title>
    <link rel="stylesheet" href="style/default-style.css">
    <style>
        /* Screen Management */
        .screen {
            display: none;
        }
        .screen.active {
            display: block;
        }

        /* Menu Screen */
        .menu-screen {
            text-align: center;
            padding: 30px;
        }
        .menu-screen h2 {
            color: #00ffff;
            font-size: 2em;
            margin-bottom: 30px;
        }
        .menu-input {
            margin: 15px 0;
        }
        .menu-input label {
            display: block;
            color: #ffff00;
            margin-bottom: 5px;
        }
        .menu-input input {
            background: #000;
            color: #00ff00;
            border: 2px inset #00ff00;
            padding: 10px 15px;
            font-size: 1.1em;
            font-family: "Comic Sans MS", cursive;
            width: 200px;
            text-align: center;
        }
        .menu-input input::placeholder {
            color: #006600;
        }
        .menu-btn {
            background: #000;
            color: #ff00ff;
            border: 3px outset #ff00ff;
            padding: 15px 30px;
            font-size: 1.2em;
            cursor: pointer;
            font-family: "Comic Sans MS", cursive;
            margin: 10px;
        }
        .menu-btn:hover {
            background: #330033;
        }
        .menu-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .menu-divider {
            color: #666;
            margin: 25px 0;
        }

        /* Recent Games */
        .recent-games-section {
            margin-top: 20px;
        }
        .recent-game-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #001a00;
            border: 2px solid #00ff00;
            padding: 10px 15px;
            margin: 8px auto;
            max-width: 320px;
            cursor: pointer;
        }
        .recent-game-item:hover {
            background: #003300;
        }
        .recent-game-info {
            text-align: left;
        }
        .recent-game-code {
            color: #00ffff;
            font-size: 1.2em;
            font-weight: bold;
        }
        .recent-game-players {
            color: #ffff00;
            font-size: 0.9em;
        }
        .recent-game-details {
            color: #888;
            font-size: 0.85em;
        }
        .recent-game-remove {
            background: none;
            border: none;
            color: #ff6666;
            cursor: pointer;
            font-size: 1.2em;
            padding: 5px;
        }
        .recent-game-remove:hover {
            color: #ff0000;
        }

        /* Gallery Screen */
        .gallery-screen {
            text-align: center;
            padding: 20px;
        }
        .gallery-btn {
            background: #000033;
            color: #00ffff;
            border-color: #00ffff;
        }
        .gallery-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            margin: 20px 0;
            max-width: 800px;
        }
        .gallery-item {
            background: #001a00;
            border: 2px solid #00ff00;
            padding: 10px;
            position: relative;
            max-width: 200px;
        }
        .gallery-screenshot {
            width: 180px;
            height: 180px;
            image-rendering: pixelated;
            border: 1px solid #333;
        }
        .gallery-info {
            margin-top: 8px;
            text-align: left;
        }
        .gallery-winner {
            color: #ffff00;
            font-weight: bold;
        }
        .gallery-scores {
            color: #00ff00;
            font-size: 0.85em;
            margin-top: 4px;
        }
        .gallery-date {
            color: #888;
            font-size: 0.8em;
            margin-top: 4px;
        }
        .gallery-remove {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            color: #ff6666;
            cursor: pointer;
            font-size: 1.2em;
        }
        .gallery-remove:hover {
            color: #ff0000;
        }

        /* Lobby Screen */
        .lobby-screen {
            text-align: center;
            padding: 30px;
        }
        .room-code-display {
            background: #000033;
            border: 3px ridge #00ffff;
            padding: 20px;
            margin: 20px auto;
            max-width: 300px;
        }
        .room-code-display label {
            color: #ffff00;
            display: block;
            margin-bottom: 10px;
        }
        .room-code {
            font-size: 3em;
            color: #00ff00;
            letter-spacing: 10px;
            font-family: monospace;
        }
        .player-list {
            background: #000033;
            border: 2px ridge #00ff00;
            padding: 15px;
            margin: 20px auto;
            max-width: 300px;
            text-align: left;
        }
        .player-list h3 {
            color: #00ffff;
            margin: 0 0 10px 0;
            text-align: center;
        }
        .player-item {
            color: #00ff00;
            padding: 5px 0;
            border-bottom: 1px dashed #003300;
        }
        .player-item:last-child {
            border-bottom: none;
        }
        .player-item.host::after {
            content: " (host)";
            color: #ffff00;
        }
        .waiting-text {
            color: #ffff00;
            animation: blink 1s infinite;
        }

        /* Game Screen */
        .game-screen {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        .game-screen.active {
            display: flex;
        }

        /* Room Code in Game */
        .game-room-code {
            background: #001a00;
            border: 2px solid #00ff00;
            padding: 5px 15px;
            color: #888;
            font-size: 0.9em;
        }
        .game-room-code span {
            color: #00ff00;
            font-weight: bold;
            letter-spacing: 2px;
        }

        /* Scoreboard */
        .scoreboard {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            background: #000033;
            border: 2px ridge #00ffff;
            padding: 10px 20px;
            min-width: 300px;
        }
        .score-item {
            text-align: center;
            padding: 5px 15px;
        }
        .score-item.current-turn {
            background: #003300;
            border: 1px solid #00ff00;
        }
        .score-item.disconnected {
            opacity: 0.5;
        }
        .score-name {
            color: #ffff00;
            font-size: 0.9em;
        }
        .score-value {
            color: #00ff00;
            font-size: 1.4em;
            font-weight: bold;
        }

        /* Scrabble Board */
        .board-container {
            position: relative;
        }
        .scrabble-board {
            display: grid;
            grid-template-columns: repeat(15, 28px);
            grid-template-rows: repeat(15, 28px);
            gap: 1px;
            background: #000;
            border: 3px ridge #00ff00;
            box-shadow: 0 0 15px #00ff0066;
        }
        .cell {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            position: relative;
            cursor: pointer;
            user-select: none;
        }
        .cell.normal { background: #c8b896; }
        .cell.tw { background: #ff6666; }
        .cell.dw { background: #ffaaaa; }
        .cell.tl { background: #6666ff; }
        .cell.dl { background: #aaaaff; }
        .cell.center { background: #ffaaaa; }
        .cell.center::before {
            content: "★";
            color: #ff6666;
            font-size: 14px;
        }

        /* Special square labels */
        .cell.tw::before { content: "TW"; font-size: 8px; color: #990000; }
        .cell.dw:not(.center)::before { content: "DW"; font-size: 8px; color: #990000; }
        .cell.tl::before { content: "TL"; font-size: 8px; color: #000099; }
        .cell.dl::before { content: "DL"; font-size: 8px; color: #000099; }

        /* Tiles on board */
        .cell.has-tile {
            background: #f5deb3;
            border: 2px outset #d4a574;
            box-sizing: border-box;
        }
        .cell.has-tile::before {
            content: none;
        }
        .cell.has-tile .tile-letter {
            font-size: 16px;
            color: #000;
        }
        .cell.has-tile .tile-score {
            position: absolute;
            bottom: 1px;
            right: 2px;
            font-size: 7px;
            color: #666;
        }
        .cell.placed-this-turn {
            background: #ffe4b5;
            border-color: #ffa500;
        }
        .cell.last-play {
            box-shadow: inset 0 0 0 2px #00ff00;
        }

        /* Tile Rack */
        .rack-container {
            background: #8b4513;
            border: 3px ridge #a0522d;
            padding: 8px 15px;
            display: flex;
            gap: 5px;
            min-height: 50px;
        }
        .rack-tile {
            width: 36px;
            height: 36px;
            background: #f5deb3;
            border: 2px outset #d4a574;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            color: #000;
            cursor: pointer;
            position: relative;
            user-select: none;
        }
        .rack-tile:hover {
            background: #ffe4b5;
        }
        .rack-tile.selected {
            background: #ffd700;
            border-style: inset;
            transform: translateY(-3px);
        }
        .rack-tile.blank {
            color: #666;
        }
        .rack-tile .tile-score {
            position: absolute;
            bottom: 1px;
            right: 3px;
            font-size: 9px;
            color: #666;
        }
        .rack-tile.empty {
            background: #654321;
            border-style: inset;
            cursor: default;
        }

        /* Drag and Drop */
        .rack-tile[draggable="true"],
        .cell[draggable="true"] {
            cursor: grab;
        }
        .rack-tile[draggable="true"]:active,
        .cell[draggable="true"]:active {
            cursor: grabbing;
        }
        .rack-tile.dragging,
        .cell.dragging {
            opacity: 0.4;
            transform: scale(0.95);
        }
        .rack-tile.drag-over {
            background: #90EE90;
            border-style: inset;
            transform: scale(1.1);
        }
        .cell.drag-over {
            background: #90EE90 !important;
            box-shadow: inset 0 0 0 3px #00ff00;
        }
        .drag-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 2000;
            opacity: 0.9;
            transform: translate(-50%, -50%) scale(1.2);
            width: 36px;
            height: 36px;
            background: #f5deb3;
            border: 2px outset #d4a574;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            color: #000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
        .drag-ghost .tile-score {
            position: absolute;
            bottom: 1px;
            right: 3px;
            font-size: 9px;
            color: #666;
        }
        .drag-ghost .tile-letter {
            font-size: 20px;
        }
        .rack-slot {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: background-color 0.15s;
        }
        .rack-slot.drag-over {
            background: rgba(144, 238, 144, 0.5);
        }
        .rack-slot .rack-tile {
            margin: 0;
        }

        /* Game Controls */
        .game-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .control-btn {
            background: #000;
            color: #00ff00;
            border: 2px outset #00ff00;
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            font-family: "Comic Sans MS", cursive;
        }
        .control-btn:hover {
            background: #003300;
        }
        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .control-btn.primary {
            border-color: #ff00ff;
            color: #ff00ff;
        }
        .control-btn.primary:hover {
            background: #330033;
        }
        .control-btn.danger {
            border-color: #ff0000;
            color: #ff0000;
        }
        .control-btn.danger:hover {
            background: #330000;
        }

        /* Status Bar */
        .status-bar {
            background: #000033;
            border: 2px ridge #00ffff;
            padding: 10px 20px;
            text-align: center;
            min-width: 300px;
        }
        .turn-indicator {
            color: #00ff00;
            font-size: 1.1em;
        }
        @keyframes blink-slow {
            0%, 96% { opacity: 1; }
            98% { opacity: 0; }
            100% { opacity: 1; }
        }
        .turn-indicator.your-turn {
            color: #ffff00;
            animation: blink-slow 15s infinite;
        }
        .tiles-remaining {
            color: #888;
            font-size: 0.9em;
            margin-top: 5px;
        }

        /* Tile Distribution Reference */
        .tile-distribution {
            background: #000033;
            border: 2px ridge #666;
            padding: 8px 12px;
            font-size: 0.75em;
            color: #888;
            max-width: 450px;
        }
        .tile-distribution summary {
            cursor: pointer;
            color: #aaa;
        }
        .tile-distribution-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 2px;
            margin-top: 8px;
        }
        .tile-dist-item {
            text-align: center;
            padding: 2px;
        }
        .tile-dist-letter {
            color: #ffff00;
            font-weight: bold;
        }
        .tile-dist-count {
            color: #888;
            font-size: 0.9em;
        }

        /* Last Play Info */
        .last-play-info {
            background: #000033;
            border: 2px ridge #00ff00;
            padding: 10px 15px;
            text-align: center;
            min-width: 280px;
        }
        .last-play-info.hidden {
            display: none;
        }
        .last-play-text {
            color: #00ffff;
            margin-bottom: 8px;
        }
        .last-play-words {
            color: #ffff00;
            font-size: 1.1em;
        }
        .challenge-buttons {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        /* Game Over Screen */
        .game-over-screen {
            text-align: center;
            padding: 30px;
        }
        .final-board-container {
            margin: 20px auto;
        }
        .final-board-image {
            border: 3px ridge #00ff00;
            box-shadow: 0 0 15px #00ff0066;
            image-rendering: pixelated;
            max-width: 100%;
            height: auto;
        }
        .final-scores {
            background: #000033;
            border: 3px ridge #00ffff;
            padding: 20px;
            margin: 20px auto;
            max-width: 300px;
        }
        .final-scores h3 {
            color: #00ffff;
            margin: 0 0 15px 0;
        }
        .final-score-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px dashed #003333;
        }
        .final-score-item:last-child {
            border-bottom: none;
        }
        .final-score-item.winner {
            color: #ffff00;
        }
        .final-rank {
            color: #888;
            width: 30px;
        }
        .final-name {
            flex: 1;
            text-align: left;
            color: #00ff00;
        }
        .final-points {
            color: #00ffff;
            font-weight: bold;
        }
        .winner-announcement {
            color: #ff00ff;
            font-size: 1.5em;
            margin: 20px 0;
            animation: blink 0.5s infinite;
        }

        /* Modal (shared styles) */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal.active {
            display: flex;
        }
        .modal-content {
            background: linear-gradient(to bottom, #000066, #660066);
            border: 5px ridge #00ff00;
            padding: 20px 30px;
            text-align: center;
            max-width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        .modal-content h3 {
            color: #00ffff;
            margin-bottom: 15px;
        }

        /* Challenge Result Modal */
        .challenge-result-modal .modal-content {
            min-width: 300px;
            max-width: 450px;
        }
        .challenge-verdict {
            font-size: 1.5em;
            font-weight: bold;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .challenge-verdict.valid {
            background: #003300;
            border: 2px solid #00ff00;
            color: #00ff00;
        }
        .challenge-verdict.invalid {
            background: #330000;
            border: 2px solid #ff0000;
            color: #ff0000;
        }
        .word-definition {
            background: #000033;
            border: 1px solid #666;
            padding: 10px;
            margin: 10px 0;
            text-align: left;
            font-size: 0.9em;
        }
        .word-definition h4 {
            color: #ffff00;
            margin: 0 0 8px 0;
        }
        .word-definition p {
            color: #ccc;
            margin: 5px 0;
        }
        .word-definition .part-of-speech {
            color: #888;
            font-style: italic;
        }
        .acknowledgment-status {
            margin: 15px 0;
            padding: 10px;
            background: #000033;
            border: 1px dashed #666;
        }
        .acknowledgment-status h4 {
            color: #888;
            margin: 0 0 10px 0;
            font-size: 0.9em;
        }
        .ack-player {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            color: #aaa;
        }
        .ack-player.acknowledged {
            color: #00ff00;
        }
        .ack-player .ack-icon {
            margin-left: 10px;
        }
        .letter-grid {
            display: grid;
            grid-template-columns: repeat(7, 35px);
            gap: 5px;
            justify-content: center;
        }
        .letter-btn {
            width: 35px;
            height: 35px;
            background: #f5deb3;
            border: 2px outset #d4a574;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
        }
        .letter-btn:hover {
            background: #ffd700;
        }

        /* Mobile Responsive */
        @media (max-width: 500px) {
            /* Maximize board size - use viewport width calculation */
            .scrabble-board {
                grid-template-columns: repeat(15, calc((100vw - 40px) / 15));
                grid-template-rows: repeat(15, calc((100vw - 40px) / 15));
            }
            .cell {
                font-size: 14px;
            }
            .cell.has-tile .tile-letter {
                font-size: 14px;
            }
            .cell.has-tile .tile-score {
                font-size: 6px;
                bottom: 0;
                right: 1px;
            }
            .cell.tw::before, .cell.dw::before,
            .cell.tl::before, .cell.dl::before {
                font-size: 5px;
            }
            .cell.center::before {
                font-size: 10px;
            }

            /* Maximize rack tile size for easier tapping */
            .rack-container {
                padding: 6px 8px;
                gap: 4px;
                justify-content: center;
                min-height: 44px;
            }
            .rack-tile {
                width: 40px;
                height: 40px;
                font-size: 22px;
            }
            .rack-tile .tile-score {
                font-size: 8px;
            }

            /* Reduce vertical spacing */
            .game-screen {
                gap: 4px;
            }
            .game-room-code {
                padding: 3px 10px;
                font-size: 0.8em;
            }
            .scoreboard {
                gap: 6px;
                padding: 6px 10px;
                min-width: auto;
                width: 100%;
                box-sizing: border-box;
            }
            .score-item {
                padding: 3px 8px;
                font-size: 0.8em;
            }
            .status-bar {
                padding: 5px 10px;
                min-width: auto;
                width: 100%;
                box-sizing: border-box;
            }
            .turn-indicator {
                font-size: 0.95em;
            }
            .tiles-remaining {
                font-size: 0.75em;
                margin-top: 1px;
            }
            .board-container {
                margin: 0;
            }
            .game-controls {
                gap: 6px;
                padding: 2px 0;
                width: 100%;
            }

            /* Play Word button stands out */
            .control-btn {
                padding: 8px 14px;
                font-size: 0.9em;
            }
            #play-btn {
                width: 100%;
                margin-top: 6px;
                padding: 12px 20px;
                font-size: 1.1em;
                order: 10; /* Push to end */
            }

            /* Hide tile distribution on mobile to save space */
            .tile-distribution {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <nav>
            <a href="index.html">Home</a>
            <a href="games.html">Games</a>
            <a href="links.html">Links</a>
        </nav>

        <h1>Scrabble</h1>

        <!-- Menu Screen -->
        <div id="menu-screen" class="screen menu-screen active">
            <h2>Online Scrabble</h2>
            <p style="color: #888;">2-4 players</p>

            <div class="menu-input">
                <label>Your Name:</label>
                <input type="text" id="player-name" placeholder="Enter name" maxlength="20">
            </div>

            <button class="menu-btn" id="create-game-btn">Create Game</button>

            <div class="menu-divider">- or -</div>

            <div class="menu-input">
                <label>Room Code:</label>
                <input type="text" id="room-code-input" placeholder="ABCD" maxlength="4" style="text-transform: uppercase;">
            </div>

            <button class="menu-btn" id="join-game-btn">Join Game</button>

            <p id="menu-error" style="color: #ff6666; margin-top: 15px;"></p>

            <!-- Recent Games Section -->
            <div id="recent-games-section" class="recent-games-section" style="display: none;">
                <div class="menu-divider">- Recent Games -</div>
                <div id="recent-games-list"></div>
            </div>

            <!-- Gallery Link -->
            <div class="menu-divider"></div>
            <button class="menu-btn gallery-btn" id="view-gallery-btn">View Gallery</button>
        </div>

        <!-- Gallery Screen -->
        <div id="gallery-screen" class="screen gallery-screen">
            <h2>Game Gallery</h2>
            <p style="color: #888;">Screenshots of finished games</p>

            <div id="gallery-games" class="gallery-container">
                <!-- Gallery items added dynamically -->
            </div>

            <button class="menu-btn" id="gallery-back-btn">Back to Menu</button>
        </div>

        <!-- Lobby Screen -->
        <div id="lobby-screen" class="screen lobby-screen">
            <h2>Game Lobby</h2>

            <div class="room-code-display">
                <label>Share this code:</label>
                <div class="room-code" id="lobby-room-code">ABCD</div>
            </div>

            <div class="player-list" id="player-list">
                <h3>Players</h3>
                <!-- Player items added dynamically -->
            </div>

            <p class="waiting-text" id="waiting-text">Waiting for players...</p>

            <button class="menu-btn" id="start-game-btn" disabled>Start Game</button>
            <button class="control-btn danger" id="leave-lobby-btn">Leave</button>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="screen game-screen">
            <!-- Room Code Display -->
            <div class="game-room-code" id="game-room-code">
                Room: <span id="game-room-code-value">ABCD</span>
            </div>

            <!-- Scoreboard -->
            <div class="scoreboard" id="scoreboard">
                <!-- Score items added dynamically -->
            </div>

            <!-- Status Bar -->
            <div class="status-bar">
                <div class="turn-indicator" id="turn-indicator">Your turn!</div>
                <div class="tiles-remaining" id="tiles-remaining">Tiles remaining: 100</div>
            </div>

            <!-- Last Play Info -->
            <div class="last-play-info hidden" id="last-play-info">
                <div class="last-play-text" id="last-play-text">Alice played:</div>
                <div class="last-play-words" id="last-play-words">"EXAMPLE" for 18 points</div>
                <div class="challenge-buttons" id="challenge-buttons">
                    <button class="control-btn danger" id="challenge-btn">Challenge</button>
                    <button class="control-btn" id="accept-word-btn">Looks Good</button>
                </div>
            </div>

            <!-- Challenge Confirmation Modal -->
            <div id="challenge-confirm-modal" class="modal">
                <div class="modal-content">
                    <h3>Challenge Word?</h3>
                    <p style="color: #ffff00; font-size: 1.3em;" id="confirm-challenge-words">"WORD"</p>
                    <p style="color: #aaa; margin: 15px 0;">Are you sure you want to challenge this word?<br>
                    If the word is valid, you will lose your next turn.</p>
                    <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                        <button class="control-btn danger" id="confirm-challenge-yes">Yes, Challenge</button>
                        <button class="control-btn" id="confirm-challenge-no">Cancel</button>
                    </div>
                </div>
            </div>

            <!-- Challenge Result Modal -->
            <div id="challenge-result-modal" class="modal challenge-result-modal">
                <div class="modal-content">
                    <h3>Challenge Result</h3>
                    <div id="challenge-verdict" class="challenge-verdict valid">VALID WORD</div>
                    <div id="challenge-definitions"></div>
                    <div id="acknowledgment-status" class="acknowledgment-status">
                        <h4>Waiting for all players to acknowledge...</h4>
                        <div id="ack-player-list"></div>
                    </div>
                    <button class="control-btn primary" id="acknowledge-btn">I Acknowledge</button>
                </div>
            </div>

            <!-- Board -->
            <div class="board-container">
                <div class="scrabble-board" id="scrabble-board">
                    <!-- Cells generated by JavaScript -->
                </div>
            </div>

            <!-- Rack -->
            <div class="rack-container" id="rack">
                <!-- Rack tiles generated by JavaScript -->
            </div>

            <!-- Game Controls -->
            <div class="game-controls">
                <button class="control-btn" id="shuffle-btn">Shuffle</button>
                <button class="control-btn" id="recall-btn">Recall</button>
                <button class="control-btn" id="pass-btn">Pass</button>
                <button class="control-btn" id="swap-btn">Swap</button>
                <button class="control-btn primary" id="play-btn" disabled>Play Word</button>
            </div>

            <!-- Tile Distribution Reference -->
            <details class="tile-distribution">
                <summary>Tile Distribution</summary>
                <div class="tile-distribution-grid">
                    <div class="tile-dist-item"><span class="tile-dist-letter">A</span><br><span class="tile-dist-count">×9</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">B</span><br><span class="tile-dist-count">×2</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">C</span><br><span class="tile-dist-count">×2</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">D</span><br><span class="tile-dist-count">×4</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">E</span><br><span class="tile-dist-count">×12</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">F</span><br><span class="tile-dist-count">×2</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">G</span><br><span class="tile-dist-count">×3</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">H</span><br><span class="tile-dist-count">×2</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">I</span><br><span class="tile-dist-count">×9</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">J</span><br><span class="tile-dist-count">×1</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">K</span><br><span class="tile-dist-count">×1</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">L</span><br><span class="tile-dist-count">×4</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">M</span><br><span class="tile-dist-count">×2</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">N</span><br><span class="tile-dist-count">×6</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">O</span><br><span class="tile-dist-count">×8</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">P</span><br><span class="tile-dist-count">×2</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">Q</span><br><span class="tile-dist-count">×1</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">R</span><br><span class="tile-dist-count">×6</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">S</span><br><span class="tile-dist-count">×4</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">T</span><br><span class="tile-dist-count">×6</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">U</span><br><span class="tile-dist-count">×4</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">V</span><br><span class="tile-dist-count">×2</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">W</span><br><span class="tile-dist-count">×2</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">X</span><br><span class="tile-dist-count">×1</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">Y</span><br><span class="tile-dist-count">×2</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">Z</span><br><span class="tile-dist-count">×1</span></div>
                    <div class="tile-dist-item"><span class="tile-dist-letter">_</span><br><span class="tile-dist-count">×2</span></div>
                </div>
            </details>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="screen game-over-screen">
            <h2 style="color: #00ffff;">Game Over!</h2>

            <div class="final-board-container">
                <img id="final-board-image" class="final-board-image" alt="Final board state">
            </div>

            <div class="final-scores" id="final-scores">
                <h3>Final Scores</h3>
                <!-- Score items added dynamically -->
            </div>

            <div class="winner-announcement" id="winner-announcement">Alice wins!</div>

            <button class="menu-btn" id="play-again-btn">Play Again</button>
            <button class="control-btn" id="back-to-menu-btn">Back to Menu</button>
        </div>

        <!-- Letter Picker Modal (for blank tiles) -->
        <div id="letter-picker-modal" class="modal">
            <div class="modal-content">
                <h3>Choose a letter:</h3>
                <div class="letter-grid" id="letter-grid">
                    <!-- A-Z buttons generated by JavaScript -->
                </div>
            </div>
        </div>

        <p style="text-align: center; margin-top: 20px;">
            <a href="games.html">&laquo; Back to Games</a>
        </p>
    </div>

    <script type="module">
        // ============================================
        // FIREBASE SETUP
        // ============================================

        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getDatabase, ref, set, get, update, onValue, onDisconnect, remove }
            from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";
        import { SCRABBLE_DICTIONARY } from "./js/scrabble-dict.js";

        const firebaseConfig = {
            apiKey: "",
            authDomain: "nino-buzz.firebaseapp.com",
            projectId: "nino-buzz",
            databaseURL: "https://nino-buzz-default-rtdb.firebaseio.com",
            storageBucket: "nino-buzz.firebasestorage.app",
            messagingSenderId: "1005714997679",
            appId: "1:1005714997679:web:94c1301de6620a0f53af5a"
        };

        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        let gameRef = null;
        let unsubscribe = null;

        // ============================================
        // CONSTANTS
        // ============================================

        const BOARD_SIZE = 15;
        const RACK_SIZE = 7;

        const TILE_DISTRIBUTION = {
            'A': 9, 'B': 2, 'C': 2, 'D': 4, 'E': 12, 'F': 2, 'G': 3, 'H': 2,
            'I': 9, 'J': 1, 'K': 1, 'L': 4, 'M': 2, 'N': 6, 'O': 8, 'P': 2,
            'Q': 1, 'R': 6, 'S': 4, 'T': 6, 'U': 4, 'V': 2, 'W': 2, 'X': 1,
            'Y': 2, 'Z': 1, '_': 2
        };

        const TILE_SCORES = {
            'A': 1, 'B': 3, 'C': 3, 'D': 2, 'E': 1, 'F': 4, 'G': 2, 'H': 4,
            'I': 1, 'J': 8, 'K': 5, 'L': 1, 'M': 3, 'N': 1, 'O': 1, 'P': 3,
            'Q': 10, 'R': 1, 'S': 1, 'T': 1, 'U': 1, 'V': 4, 'W': 4, 'X': 8,
            'Y': 4, 'Z': 10, '_': 0
        };

        const BINGO_BONUS = 50;

        // Special square positions
        const SPECIAL_SQUARES = {
            TW: [[0,0], [0,7], [0,14], [7,0], [7,14], [14,0], [14,7], [14,14]],
            DW: [[1,1], [2,2], [3,3], [4,4], [1,13], [2,12], [3,11], [4,10],
                 [10,4], [11,3], [12,2], [13,1], [10,10], [11,11], [12,12], [13,13]],
            TL: [[1,5], [1,9], [5,1], [5,5], [5,9], [5,13],
                 [9,1], [9,5], [9,9], [9,13], [13,5], [13,9]],
            DL: [[0,3], [0,11], [2,6], [2,8], [3,0], [3,7], [3,14],
                 [6,2], [6,6], [6,8], [6,12], [7,3], [7,11],
                 [8,2], [8,6], [8,8], [8,12], [11,0], [11,7], [11,14],
                 [12,6], [12,8], [14,3], [14,11]]
        };

        // ============================================
        // GAME STATE
        // ============================================

        let gameState = null;
        let localState = {
            playerId: null,
            playerName: '',
            roomCode: null,
            selectedRackIndex: null,
            placedTiles: [],  // { rackIndex, row, col, letter, isBlank, blankLetter }
            isHost: false
        };

        // ============================================
        // DOM ELEMENTS
        // ============================================

        const screens = {
            menu: document.getElementById('menu-screen'),
            lobby: document.getElementById('lobby-screen'),
            game: document.getElementById('game-screen'),
            gameOver: document.getElementById('game-over-screen'),
            gallery: document.getElementById('gallery-screen')
        };

        const elements = {
            playerNameInput: document.getElementById('player-name'),
            roomCodeInput: document.getElementById('room-code-input'),
            menuError: document.getElementById('menu-error'),
            lobbyRoomCode: document.getElementById('lobby-room-code'),
            playerList: document.getElementById('player-list'),
            waitingText: document.getElementById('waiting-text'),
            startGameBtn: document.getElementById('start-game-btn'),
            board: document.getElementById('scrabble-board'),
            rack: document.getElementById('rack'),
            scoreboard: document.getElementById('scoreboard'),
            turnIndicator: document.getElementById('turn-indicator'),
            tilesRemaining: document.getElementById('tiles-remaining'),
            lastPlayInfo: document.getElementById('last-play-info'),
            letterPickerModal: document.getElementById('letter-picker-modal'),
            letterGrid: document.getElementById('letter-grid'),
            playBtn: document.getElementById('play-btn'),
            finalScores: document.getElementById('final-scores'),
            winnerAnnouncement: document.getElementById('winner-announcement')
        };

        // ============================================
        // SCREEN MANAGEMENT
        // ============================================

        function showScreen(screenName) {
            Object.values(screens).forEach(s => s.classList.remove('active'));
            screens[screenName].classList.add('active');

            // Refresh recent games when returning to menu
            if (screenName === 'menu') {
                renderRecentGames();
            }
        }

        // ============================================
        // BOARD RENDERING
        // ============================================

        function getSquareType(row, col) {
            if (row === 7 && col === 7) return 'center';
            for (const [type, positions] of Object.entries(SPECIAL_SQUARES)) {
                if (positions.some(([r, c]) => r === row && c === col)) {
                    return type.toLowerCase();
                }
            }
            return 'normal';
        }

        function createBoard() {
            elements.board.innerHTML = '';
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const cell = document.createElement('div');
                    const squareType = getSquareType(row, col);
                    cell.className = `cell ${squareType}`;
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.onclick = () => handleCellClick(row, col);

                    // Drag and drop handlers for receiving drops
                    cell.addEventListener('dragover', handleCellDragOver);
                    cell.addEventListener('dragleave', handleCellDragLeave);
                    cell.addEventListener('drop', handleCellDrop);

                    elements.board.appendChild(cell);
                }
            }

            // Event delegation for dragging placed tiles (added once on container)
            elements.board.addEventListener('dragstart', (e) => {
                const cell = e.target.closest('.cell');
                if (cell && cell.classList.contains('placed-this-turn')) {
                    handleBoardDragStart(e);
                }
            });
            elements.board.addEventListener('dragend', handleDragEnd);

            // Touch event delegation for dragging placed tiles
            elements.board.addEventListener('touchstart', (e) => {
                const cell = e.target.closest('.cell');
                if (cell && cell.classList.contains('placed-this-turn')) {
                    handleBoardTouchStart(e);
                }
            }, { passive: false });
            elements.board.addEventListener('touchmove', handleTouchMove, { passive: false });
            elements.board.addEventListener('touchend', (e) => {
                // If there's an active drag, use the drag handler
                if (dragState.touchIdentifier !== null) {
                    handleTouchEnd(e);
                    return;
                }

                // Otherwise, handle as a tap on a cell (for placing selected tiles)
                const touch = e.changedTouches[0];
                if (!touch) return;

                const cell = e.target.closest('.cell');
                if (cell) {
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    handleCellClick(row, col);
                }
            });
        }

        function renderBoard() {
            // Clear placed tiles display
            document.querySelectorAll('.cell').forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const key = `${row},${col}`;

                // Check if there's a permanent tile here
                const boardTile = gameState?.board?.[key];
                // Check if there's a temporarily placed tile here
                const placedTile = localState.placedTiles.find(t => t.row === row && t.col === col);

                cell.classList.remove('has-tile', 'placed-this-turn', 'last-play');
                cell.innerHTML = '';

                if (placedTile) {
                    cell.classList.add('has-tile', 'placed-this-turn');
                    const letter = placedTile.blankLetter || placedTile.letter;
                    const score = placedTile.isBlank ? '' : TILE_SCORES[placedTile.letter];
                    cell.innerHTML = `<span class="tile-letter">${letter}</span>
                                      <span class="tile-score">${score}</span>`;

                    // Make placed tiles draggable
                    cell.draggable = true;
                    cell.dataset.placedRow = row;
                    cell.dataset.placedCol = col;
                } else if (boardTile) {
                    cell.classList.add('has-tile');
                    cell.draggable = false;
                    const score = boardTile.isBlank ? '' : TILE_SCORES[boardTile.letter];
                    cell.innerHTML = `<span class="tile-letter">${boardTile.letter}</span>
                                      <span class="tile-score">${score}</span>`;
                    // Highlight last play
                    if (gameState?.lastPlay?.tiles?.some(t => t.row === row && t.col === col)) {
                        cell.classList.add('last-play');
                    }
                } else {
                    // Restore special square label
                    const squareType = getSquareType(row, col);
                    cell.className = `cell ${squareType}`;
                    cell.draggable = false;
                }
            });

            updatePlayButton();
        }

        // ============================================
        // RACK RENDERING
        // ============================================

        function renderRack() {
            elements.rack.innerHTML = '';

            const rack = gameState?.players?.[localState.playerId]?.rack || [];

            for (let i = 0; i < RACK_SIZE; i++) {
                // Create a slot wrapper for drag-over detection
                const slot = document.createElement('div');
                slot.className = 'rack-slot';
                slot.dataset.rackIndex = i;

                const tile = document.createElement('div');

                // Check if this rack position has been placed on board
                const isPlaced = localState.placedTiles.some(t => t.rackIndex === i);

                if (i < rack.length && !isPlaced) {
                    const letter = rack[i];
                    const isBlank = letter === '_';
                    tile.className = 'rack-tile' + (isBlank ? ' blank' : '');
                    tile.innerHTML = `${isBlank ? ' ' : letter}<span class="tile-score">${TILE_SCORES[letter]}</span>`;
                    tile.onclick = () => handleRackClick(i);
                    tile.dataset.rackIndex = i;
                    tile.dataset.letter = letter;

                    // Drag attributes
                    tile.draggable = true;
                    tile.addEventListener('dragstart', handleRackDragStart);
                    tile.addEventListener('dragend', handleDragEnd);

                    // Touch drag support
                    tile.addEventListener('touchstart', handleTouchStart, { passive: false });
                    tile.addEventListener('touchmove', handleTouchMove, { passive: false });
                    tile.addEventListener('touchend', handleTouchEnd);

                    if (localState.selectedRackIndex === i) {
                        tile.classList.add('selected');
                    }
                } else {
                    tile.className = 'rack-tile empty';
                }

                // Rack slot drop handlers (for reordering)
                slot.addEventListener('dragover', handleRackSlotDragOver);
                slot.addEventListener('dragleave', handleRackSlotDragLeave);
                slot.addEventListener('drop', handleRackSlotDrop);

                slot.appendChild(tile);
                elements.rack.appendChild(slot);
            }
        }

        // ============================================
        // TILE PLACEMENT
        // ============================================

        function handleRackClick(index) {
            const rack = gameState?.players?.[localState.playerId]?.rack || [];
            if (index >= rack.length) return;

            // Check if already placed
            if (localState.placedTiles.some(t => t.rackIndex === index)) return;

            // Toggle selection
            if (localState.selectedRackIndex === index) {
                localState.selectedRackIndex = null;
            } else {
                localState.selectedRackIndex = index;
            }

            renderRack();
        }

        function handleCellClick(row, col) {
            // Check if we're clicking on a placed tile to remove it
            const placedIndex = localState.placedTiles.findIndex(t => t.row === row && t.col === col);
            if (placedIndex !== -1) {
                localState.placedTiles.splice(placedIndex, 1);
                localState.selectedRackIndex = null;
                renderBoard();
                renderRack();
                return;
            }

            // Check if cell already has a permanent tile
            const key = `${row},${col}`;
            if (gameState?.board?.[key]) return;

            // Place selected tile
            if (localState.selectedRackIndex !== null) {
                const rack = gameState?.players?.[localState.playerId]?.rack || [];
                const letter = rack[localState.selectedRackIndex];
                const isBlank = letter === '_';

                if (isBlank) {
                    // Show letter picker
                    showLetterPicker((chosenLetter) => {
                        localState.placedTiles.push({
                            rackIndex: localState.selectedRackIndex,
                            row,
                            col,
                            letter: '_',
                            isBlank: true,
                            blankLetter: chosenLetter
                        });
                        localState.selectedRackIndex = null;
                        renderBoard();
                        renderRack();
                    });
                } else {
                    localState.placedTiles.push({
                        rackIndex: localState.selectedRackIndex,
                        row,
                        col,
                        letter,
                        isBlank: false,
                        blankLetter: null
                    });
                    localState.selectedRackIndex = null;
                    renderBoard();
                    renderRack();
                }
            }
        }

        function showLetterPicker(callback) {
            elements.letterGrid.innerHTML = '';
            for (let i = 0; i < 26; i++) {
                const letter = String.fromCharCode(65 + i);
                const btn = document.createElement('button');
                btn.className = 'letter-btn';
                btn.textContent = letter;
                btn.onclick = () => {
                    elements.letterPickerModal.classList.remove('active');
                    callback(letter);
                };
                elements.letterGrid.appendChild(btn);
            }
            elements.letterPickerModal.classList.add('active');
        }

        function recallTiles() {
            localState.placedTiles = [];
            localState.selectedRackIndex = null;
            renderBoard();
            renderRack();
        }

        function shuffleRack() {
            if (!gameState?.players?.[localState.playerId]?.rack) return;

            // Fisher-Yates shuffle
            const rack = [...gameState.players[localState.playerId].rack];
            for (let i = rack.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [rack[i], rack[j]] = [rack[j], rack[i]];
            }
            gameState.players[localState.playerId].rack = rack;

            // Clear any placed tiles since rack order changed
            localState.placedTiles = [];
            localState.selectedRackIndex = null;
            renderRack();
            renderBoard();
        }

        // ============================================
        // DRAG AND DROP
        // ============================================

        let dragState = {
            sourceType: null,      // 'rack' or 'board'
            rackIndex: null,
            boardRow: null,
            boardCol: null,
            letter: null,
            ghostElement: null,
            touchIdentifier: null,
            // Touch tap vs drag detection
            startX: null,
            startY: null,
            isDragging: false,
            sourceElement: null
        };

        const DRAG_THRESHOLD = 10; // pixels to move before it's considered a drag

        function handleRackDragStart(e) {
            const rackIndex = parseInt(e.target.dataset.rackIndex);
            dragState.sourceType = 'rack';
            dragState.rackIndex = rackIndex;
            dragState.letter = e.target.dataset.letter;
            e.target.classList.add('dragging');

            // Set drag image
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', rackIndex.toString());
        }

        function handleBoardDragStart(e) {
            const cell = e.target.closest('.cell');
            if (!cell) return;

            const row = parseInt(cell.dataset.placedRow);
            const col = parseInt(cell.dataset.placedCol);
            const placedTile = localState.placedTiles.find(t => t.row === row && t.col === col);
            if (!placedTile) return;

            dragState.sourceType = 'board';
            dragState.boardRow = row;
            dragState.boardCol = col;
            dragState.rackIndex = placedTile.rackIndex;
            dragState.letter = placedTile.blankLetter || placedTile.letter;
            cell.classList.add('dragging');

            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', `${row},${col}`);
        }

        function handleDragEnd(e) {
            const el = e.target.closest('.cell') || e.target.closest('.rack-tile') || e.target;
            el.classList.remove('dragging');
            clearDragState();
        }

        function clearDragState() {
            dragState.sourceType = null;
            dragState.rackIndex = null;
            dragState.boardRow = null;
            dragState.boardCol = null;
            dragState.letter = null;
            if (dragState.ghostElement) {
                dragState.ghostElement.remove();
                dragState.ghostElement = null;
            }
            dragState.touchIdentifier = null;
            dragState.startX = null;
            dragState.startY = null;
            dragState.isDragging = false;
            if (dragState.sourceElement) {
                dragState.sourceElement.classList.remove('dragging');
                dragState.sourceElement = null;
            }

            // Remove all drag-over states
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        }

        // Rack slot handlers (for reordering)
        function handleRackSlotDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            e.currentTarget.classList.add('drag-over');
        }

        function handleRackSlotDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }

        function handleRackSlotDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');

            const targetIndex = parseInt(e.currentTarget.dataset.rackIndex);

            if (dragState.sourceType === 'rack') {
                // Reorder rack
                swapRackTiles(dragState.rackIndex, targetIndex);
            } else if (dragState.sourceType === 'board') {
                // Return tile from board to rack
                returnTileToRack(dragState.boardRow, dragState.boardCol);
            }

            clearDragState();
        }

        // Board cell handlers
        function handleCellDragOver(e) {
            e.preventDefault();
            const cell = e.target.closest('.cell');
            if (!cell) return;

            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            const key = `${row},${col}`;

            // Only allow dropping on empty cells or cells we placed this turn
            if (gameState?.board?.[key]) return;

            // Don't allow dropping on the same cell for board drags
            if (dragState.sourceType === 'board' && dragState.boardRow === row && dragState.boardCol === col) return;

            e.dataTransfer.dropEffect = 'move';
            cell.classList.add('drag-over');
        }

        function handleCellDragLeave(e) {
            const cell = e.target.closest('.cell');
            if (cell) cell.classList.remove('drag-over');
        }

        function handleCellDrop(e) {
            e.preventDefault();
            const cell = e.target.closest('.cell');
            if (!cell) return;
            cell.classList.remove('drag-over');

            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            const key = `${row},${col}`;

            // Check if cell has permanent tile
            if (gameState?.board?.[key]) return;

            // Check if already has a placed tile
            const existingPlacedIndex = localState.placedTiles.findIndex(t => t.row === row && t.col === col);
            if (existingPlacedIndex !== -1) return;

            if (dragState.sourceType === 'rack') {
                // Place tile from rack to board
                placeTileOnBoard(dragState.rackIndex, row, col);
            } else if (dragState.sourceType === 'board') {
                // Move tile from one board position to another
                movePlacedTile(dragState.boardRow, dragState.boardCol, row, col);
            }

            clearDragState();
        }

        function swapRackTiles(fromIndex, toIndex) {
            if (fromIndex === toIndex) return;
            if (!gameState?.players?.[localState.playerId]?.rack) return;

            const rack = gameState.players[localState.playerId].rack;
            if (fromIndex >= rack.length || toIndex >= rack.length) return;

            // Simple swap
            const temp = rack[fromIndex];
            rack[fromIndex] = rack[toIndex];
            rack[toIndex] = temp;

            // Update placed tiles indices
            localState.placedTiles.forEach(tile => {
                if (tile.rackIndex === fromIndex) {
                    tile.rackIndex = toIndex;
                } else if (tile.rackIndex === toIndex) {
                    tile.rackIndex = fromIndex;
                }
            });

            localState.selectedRackIndex = null;
            renderRack();
        }

        function returnTileToRack(row, col) {
            const index = localState.placedTiles.findIndex(t => t.row === row && t.col === col);
            if (index !== -1) {
                localState.placedTiles.splice(index, 1);
                localState.selectedRackIndex = null;
                renderBoard();
                renderRack();
            }
        }

        function placeTileOnBoard(rackIndex, row, col) {
            const rack = gameState?.players?.[localState.playerId]?.rack || [];
            const letter = rack[rackIndex];
            const isBlank = letter === '_';

            // Check if already placed
            if (localState.placedTiles.some(t => t.rackIndex === rackIndex)) return;

            if (isBlank) {
                showLetterPicker((chosenLetter) => {
                    localState.placedTiles.push({
                        rackIndex,
                        row,
                        col,
                        letter: '_',
                        isBlank: true,
                        blankLetter: chosenLetter
                    });
                    localState.selectedRackIndex = null;
                    renderBoard();
                    renderRack();
                });
            } else {
                localState.placedTiles.push({
                    rackIndex,
                    row,
                    col,
                    letter,
                    isBlank: false,
                    blankLetter: null
                });
                localState.selectedRackIndex = null;
                renderBoard();
                renderRack();
            }
        }

        function movePlacedTile(fromRow, fromCol, toRow, toCol) {
            const tile = localState.placedTiles.find(t => t.row === fromRow && t.col === fromCol);
            if (tile) {
                tile.row = toRow;
                tile.col = toCol;
                renderBoard();
            }
        }

        // ============================================
        // TOUCH DRAG SUPPORT
        // ============================================

        function handleTouchStart(e) {
            if (e.touches.length !== 1) return;

            const touch = e.touches[0];
            const tile = e.target.closest('.rack-tile');
            if (!tile || tile.classList.contains('empty')) return;

            // Don't preventDefault yet - we need to detect if this is a tap or drag
            // Store touch info for potential drag
            dragState.touchIdentifier = touch.identifier;
            dragState.sourceType = 'rack';
            dragState.rackIndex = parseInt(tile.dataset.rackIndex);
            dragState.letter = tile.dataset.letter;
            dragState.startX = touch.clientX;
            dragState.startY = touch.clientY;
            dragState.isDragging = false;
            dragState.sourceElement = tile;
        }

        function handleBoardTouchStart(e) {
            if (e.touches.length !== 1) return;

            const touch = e.touches[0];
            const cell = e.target.closest('.cell');
            if (!cell || !cell.classList.contains('placed-this-turn')) return;

            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            const placedTile = localState.placedTiles.find(t => t.row === row && t.col === col);
            if (!placedTile) return;

            // Don't preventDefault yet - we need to detect if this is a tap or drag
            dragState.touchIdentifier = touch.identifier;
            dragState.sourceType = 'board';
            dragState.boardRow = row;
            dragState.boardCol = col;
            dragState.rackIndex = placedTile.rackIndex;
            dragState.letter = placedTile.blankLetter || placedTile.letter;
            dragState.startX = touch.clientX;
            dragState.startY = touch.clientY;
            dragState.isDragging = false;
            dragState.sourceElement = cell;
        }

        function createTouchGhost(sourceEl, x, y) {
            const ghost = document.createElement('div');
            ghost.className = 'rack-tile drag-ghost';
            ghost.innerHTML = sourceEl.innerHTML;
            ghost.style.left = x + 'px';
            ghost.style.top = y + 'px';
            document.body.appendChild(ghost);
            dragState.ghostElement = ghost;
        }

        function handleTouchMove(e) {
            if (dragState.touchIdentifier === null) return;

            const touch = Array.from(e.touches).find(t => t.identifier === dragState.touchIdentifier);
            if (!touch) return;

            // Check if we've moved beyond the drag threshold
            if (!dragState.isDragging) {
                const dx = touch.clientX - dragState.startX;
                const dy = touch.clientY - dragState.startY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < DRAG_THRESHOLD) {
                    // Not dragging yet, don't prevent default
                    return;
                }

                // Start dragging
                dragState.isDragging = true;
                if (dragState.sourceElement) {
                    dragState.sourceElement.classList.add('dragging');
                    createTouchGhost(dragState.sourceElement, touch.clientX, touch.clientY);
                }
            }

            e.preventDefault();

            // Move ghost
            if (dragState.ghostElement) {
                dragState.ghostElement.style.left = touch.clientX + 'px';
                dragState.ghostElement.style.top = touch.clientY + 'px';
            }

            // Find element under touch
            const elemUnder = document.elementFromPoint(touch.clientX, touch.clientY);

            // Clear previous drag-over states
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));

            if (elemUnder) {
                // Check for rack slot
                const rackSlot = elemUnder.closest('.rack-slot');
                if (rackSlot) {
                    rackSlot.classList.add('drag-over');
                    return;
                }

                // Check for board cell
                const cell = elemUnder.closest('.cell');
                if (cell) {
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    const key = `${row},${col}`;

                    // Only show drop indicator on valid cells
                    if (!gameState?.board?.[key]) {
                        if (dragState.sourceType !== 'board' ||
                            dragState.boardRow !== row ||
                            dragState.boardCol !== col) {
                            cell.classList.add('drag-over');
                        }
                    }
                }
            }
        }

        function handleTouchEnd(e) {
            if (dragState.touchIdentifier === null) return;

            const touch = Array.from(e.changedTouches).find(t => t.identifier === dragState.touchIdentifier);
            if (!touch) {
                clearDragState();
                return;
            }

            // If we weren't dragging, treat this as a tap
            if (!dragState.isDragging) {
                if (dragState.sourceType === 'rack') {
                    // Tap on rack tile - toggle selection
                    handleRackClick(dragState.rackIndex);
                } else if (dragState.sourceType === 'board') {
                    // Tap on placed tile - remove it
                    handleCellClick(dragState.boardRow, dragState.boardCol);
                }
                clearDragState();
                return;
            }

            e.preventDefault();

            // Find drop target
            const elemUnder = document.elementFromPoint(touch.clientX, touch.clientY);

            if (elemUnder) {
                // Check for rack slot drop
                const rackSlot = elemUnder.closest('.rack-slot');
                if (rackSlot) {
                    const targetIndex = parseInt(rackSlot.dataset.rackIndex);
                    if (dragState.sourceType === 'rack') {
                        swapRackTiles(dragState.rackIndex, targetIndex);
                    } else if (dragState.sourceType === 'board') {
                        returnTileToRack(dragState.boardRow, dragState.boardCol);
                    }
                } else {
                    // Check for board cell drop
                    const cell = elemUnder.closest('.cell');
                    if (cell) {
                        const row = parseInt(cell.dataset.row);
                        const col = parseInt(cell.dataset.col);
                        const key = `${row},${col}`;

                        if (!gameState?.board?.[key]) {
                            const existingPlacedIndex = localState.placedTiles.findIndex(t => t.row === row && t.col === col);
                            if (existingPlacedIndex === -1) {
                                if (dragState.sourceType === 'rack') {
                                    placeTileOnBoard(dragState.rackIndex, row, col);
                                } else if (dragState.sourceType === 'board') {
                                    movePlacedTile(dragState.boardRow, dragState.boardCol, row, col);
                                }
                            }
                        }
                    }
                }
            }

            // Remove dragging state from source
            document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
            clearDragState();
        }

        // ============================================
        // PLAY VALIDATION & GAME LOGIC
        // ============================================

        function updatePlayButton() {
            const canPlay = localState.placedTiles.length > 0 && isMyTurn() && !gameState?.pendingChallenge;
            elements.playBtn.disabled = !canPlay;
        }

        function isMyTurn() {
            return gameState?.currentTurn === localState.playerId && !gameState?.pendingChallenge;
        }

        // Get a tile at a position (from board or placed tiles)
        function getTileAt(row, col) {
            const key = `${row},${col}`;
            const boardTile = gameState?.board?.[key];
            if (boardTile) return boardTile;

            const placedTile = localState.placedTiles.find(t => t.row === row && t.col === col);
            if (placedTile) {
                return {
                    letter: placedTile.blankLetter || placedTile.letter,
                    isBlank: placedTile.isBlank
                };
            }
            return null;
        }

        // Check if board is empty (first move)
        function isBoardEmpty() {
            return !gameState?.board || Object.keys(gameState.board).length === 0;
        }

        // Validate tile placement
        function validatePlacement() {
            const placed = localState.placedTiles;
            if (placed.length === 0) {
                return { valid: false, error: "No tiles placed" };
            }

            // Check all tiles are in same row OR same column
            const rows = [...new Set(placed.map(t => t.row))];
            const cols = [...new Set(placed.map(t => t.col))];

            if (rows.length > 1 && cols.length > 1) {
                return { valid: false, error: "Tiles must be in a straight line" };
            }

            const isHorizontal = rows.length === 1;
            const fixedAxis = isHorizontal ? rows[0] : cols[0];
            const positions = isHorizontal
                ? placed.map(t => t.col).sort((a, b) => a - b)
                : placed.map(t => t.row).sort((a, b) => a - b);

            // Check for gaps (all positions between min and max must have a tile)
            const minPos = positions[0];
            const maxPos = positions[positions.length - 1];

            for (let pos = minPos; pos <= maxPos; pos++) {
                const row = isHorizontal ? fixedAxis : pos;
                const col = isHorizontal ? pos : fixedAxis;
                if (!getTileAt(row, col)) {
                    return { valid: false, error: "Gaps are not allowed" };
                }
            }

            // Check connection to existing tiles (or center square for first move)
            if (isBoardEmpty()) {
                // First move must cover center square
                const coversCenter = placed.some(t => t.row === 7 && t.col === 7);
                if (!coversCenter) {
                    return { valid: false, error: "First word must cover center square" };
                }
                // First move must be at least 2 letters
                if (placed.length < 2) {
                    return { valid: false, error: "Word must be at least 2 letters" };
                }
            } else {
                // Must connect to at least one existing tile
                let connected = false;
                for (const tile of placed) {
                    const neighbors = [
                        [tile.row - 1, tile.col],
                        [tile.row + 1, tile.col],
                        [tile.row, tile.col - 1],
                        [tile.row, tile.col + 1]
                    ];
                    for (const [r, c] of neighbors) {
                        if (r >= 0 && r < 15 && c >= 0 && c < 15) {
                            const key = `${r},${c}`;
                            if (gameState?.board?.[key]) {
                                connected = true;
                                break;
                            }
                        }
                    }
                    if (connected) break;
                }
                if (!connected) {
                    return { valid: false, error: "Must connect to existing tiles" };
                }
            }

            // Find all words formed
            const words = findAllWords(isHorizontal);
            if (words.length === 0) {
                return { valid: false, error: "No valid words formed" };
            }

            // Calculate score
            const score = calculateScore(words);

            return { valid: true, words, score };
        }

        // Find all words formed by the current placement
        function findAllWords(isHorizontal) {
            const words = [];
            const placed = localState.placedTiles;

            // Find the main word (along the placement direction)
            const mainWord = findWordThrough(placed[0].row, placed[0].col, isHorizontal);
            if (mainWord.text.length > 1) {
                words.push(mainWord);
            }

            // Find perpendicular words formed by each placed tile
            for (const tile of placed) {
                const crossWord = findWordThrough(tile.row, tile.col, !isHorizontal);
                if (crossWord.text.length > 1) {
                    // Avoid duplicates
                    const isDuplicate = words.some(w =>
                        w.text === crossWord.text &&
                        w.startRow === crossWord.startRow &&
                        w.startCol === crossWord.startCol
                    );
                    if (!isDuplicate) {
                        words.push(crossWord);
                    }
                }
            }

            return words;
        }

        // Find a word passing through a given position
        function findWordThrough(row, col, horizontal) {
            let startRow = row;
            let startCol = col;

            // Find start of word
            while (true) {
                const prevRow = horizontal ? startRow : startRow - 1;
                const prevCol = horizontal ? startCol - 1 : startCol;
                if (prevRow < 0 || prevCol < 0) break;
                if (!getTileAt(prevRow, prevCol)) break;
                startRow = prevRow;
                startCol = prevCol;
            }

            // Read the word
            let text = '';
            let tiles = [];
            let r = startRow;
            let c = startCol;

            while (r < 15 && c < 15) {
                const tile = getTileAt(r, c);
                if (!tile) break;

                text += tile.letter;
                tiles.push({
                    row: r,
                    col: c,
                    letter: tile.letter,
                    isBlank: tile.isBlank,
                    isNew: localState.placedTiles.some(t => t.row === r && t.col === c)
                });

                if (horizontal) c++; else r++;
            }

            return { text, tiles, startRow, startCol, horizontal };
        }

        // Calculate score for all words
        function calculateScore(words) {
            let totalScore = 0;

            for (const word of words) {
                let wordScore = 0;
                let wordMultiplier = 1;

                for (const tile of word.tiles) {
                    let letterScore = tile.isBlank ? 0 : TILE_SCORES[tile.letter] || 0;

                    // Only apply bonuses for newly placed tiles
                    if (tile.isNew) {
                        const squareType = getSquareType(tile.row, tile.col);
                        switch (squareType) {
                            case 'dl':
                                letterScore *= 2;
                                break;
                            case 'tl':
                                letterScore *= 3;
                                break;
                            case 'dw':
                            case 'center':
                                wordMultiplier *= 2;
                                break;
                            case 'tw':
                                wordMultiplier *= 3;
                                break;
                        }
                    }

                    wordScore += letterScore;
                }

                totalScore += wordScore * wordMultiplier;
            }

            // Bingo bonus for using all 7 tiles
            if (localState.placedTiles.length === 7) {
                totalScore += BINGO_BONUS;
            }

            return totalScore;
        }

        // Attempt to play the current tiles
        function attemptPlay() {
            const validation = validatePlacement();

            if (!validation.valid) {
                showError(validation.error);
                return null;
            }

            return {
                tiles: localState.placedTiles.map(t => ({
                    row: t.row,
                    col: t.col,
                    letter: t.blankLetter || t.letter,
                    originalLetter: t.letter,
                    isBlank: t.isBlank
                })),
                words: validation.words.map(w => w.text),
                score: validation.score
            };
        }

        function showError(message) {
            // Show error in turn indicator temporarily
            const original = elements.turnIndicator.textContent;
            elements.turnIndicator.textContent = message;
            elements.turnIndicator.style.color = '#ff6666';
            setTimeout(() => {
                elements.turnIndicator.textContent = original;
                elements.turnIndicator.style.color = '';
            }, 2000);
        }

        // ============================================
        // UI UPDATES
        // ============================================

        function updateScoreboard() {
            elements.scoreboard.innerHTML = '';
            if (!gameState?.players) return;

            const playerOrder = gameState.playerOrder || Object.keys(gameState.players);

            for (const playerId of playerOrder) {
                const player = gameState.players[playerId];
                if (!player) continue;

                const item = document.createElement('div');
                item.className = 'score-item';
                if (playerId === gameState.currentTurn) {
                    item.classList.add('current-turn');
                }
                if (!player.connected) {
                    item.classList.add('disconnected');
                }

                const nameDiv = document.createElement('div');
                nameDiv.className = 'score-name';
                nameDiv.textContent = player.name + (playerId === localState.playerId ? ' (you)' : '');
                if (!player.connected) {
                    const icon = document.createElement('span');
                    icon.style.color = '#ff6666';
                    icon.textContent = ' ⚠';
                    nameDiv.appendChild(icon);
                }

                const scoreDiv = document.createElement('div');
                scoreDiv.className = 'score-value';
                scoreDiv.textContent = player.score || 0;

                item.appendChild(nameDiv);
                item.appendChild(scoreDiv);
                elements.scoreboard.appendChild(item);
            }
        }

        function updateTurnIndicator() {
            if (!gameState) return;

            const currentPlayer = gameState.players?.[gameState.currentTurn];
            const isMyTurn = gameState.currentTurn === localState.playerId;
            const isDisconnected = currentPlayer && !currentPlayer.connected;

            elements.turnIndicator.className = 'turn-indicator' + (isMyTurn ? ' your-turn' : '');

            if (isMyTurn) {
                elements.turnIndicator.textContent = "Your turn - play a word!";
            } else if (isDisconnected) {
                elements.turnIndicator.textContent = `Waiting for ${currentPlayer?.name || 'opponent'} (disconnected)...`;
                elements.turnIndicator.style.color = '#ff6666';
            } else {
                elements.turnIndicator.textContent = `Waiting for ${currentPlayer?.name || 'opponent'}...`;
                elements.turnIndicator.style.color = '';
            }

            elements.tilesRemaining.textContent = `Tiles remaining: ${gameState.tilesRemaining || 0}`;
        }

        function updateLastPlayInfo() {
            const lastPlay = gameState?.lastPlay;

            if (!lastPlay || !lastPlay.words || lastPlay.words.length === 0) {
                elements.lastPlayInfo.classList.add('hidden');
                return;
            }

            elements.lastPlayInfo.classList.remove('hidden');

            const playerName = gameState.players?.[lastPlay.player]?.name || 'Someone';
            document.getElementById('last-play-text').textContent = `${playerName} played:`;
            document.getElementById('last-play-words').textContent =
                `"${lastPlay.words.join('", "')}" for ${lastPlay.score} points`;

            // Show challenge button if not my turn and play is challengeable
            const challengeButtons = document.getElementById('challenge-buttons');
            if (lastPlay.challengeable && lastPlay.player !== localState.playerId) {
                challengeButtons.style.display = 'flex';
            } else {
                challengeButtons.style.display = 'none';
            }
        }

        function updateLobby() {
            if (!gameState) return;

            elements.lobbyRoomCode.textContent = localState.roomCode;

            // Update player list
            const listHtml = '<h3>Players</h3>';
            elements.playerList.innerHTML = listHtml;

            const playerOrder = gameState.playerOrder || [];
            for (const playerId of playerOrder) {
                const player = gameState.players?.[playerId];
                if (!player) continue;

                const item = document.createElement('div');
                item.className = 'player-item';
                if (playerId === gameState.hostId) {
                    item.classList.add('host');
                }
                item.textContent = player.name + (playerId === localState.playerId ? ' (you)' : '');
                elements.playerList.appendChild(item);
            }

            // Update waiting text and start button
            const playerCount = playerOrder.length;
            elements.waitingText.textContent = `${playerCount}/4 players`;

            if (localState.isHost) {
                elements.startGameBtn.style.display = 'inline-block';
                elements.startGameBtn.disabled = playerCount < 2;
            } else {
                elements.startGameBtn.style.display = 'none';
            }
        }

        // ============================================
        // GAME STATE SYNC (placeholder for Firebase)
        // ============================================

        function onGameStateUpdate(newState) {
            gameState = newState;

            if (gameState.status === 'waiting') {
                showScreen('lobby');
                updateLobby();
            } else if (gameState.status === 'playing') {
                showScreen('game');
                document.getElementById('game-room-code-value').textContent = localState.roomCode;
                renderBoard();
                renderRack();
                updateScoreboard();
                updateTurnIndicator();
                updateLastPlayInfo();
                updateChallengePending();
            } else if (gameState.status === 'finished') {
                showScreen('gameOver');
                showFinalScores();
            }

            // Keep session updated with latest player info
            updateSessionFromGameState();
        }

        function showFinalScores() {
            if (!gameState?.players) return;

            // Capture and display the final board state
            const boardImage = captureBoardImage();
            document.getElementById('final-board-image').src = boardImage;

            // Calculate final scores (subtract remaining rack values)
            const finalScores = [];
            let totalRackValue = 0;
            let winnerPlayerId = null;

            for (const [playerId, player] of Object.entries(gameState.players)) {
                const rackValue = (player.rack || []).reduce((sum, letter) =>
                    sum + (TILE_SCORES[letter] || 0), 0);
                totalRackValue += rackValue;

                finalScores.push({
                    playerId,
                    name: player.name,
                    baseScore: player.score || 0,
                    rackValue,
                    finalScore: (player.score || 0) - rackValue,
                    wentOut: (player.rack || []).length === 0
                });
            }

            // Player who went out gets everyone's rack values added
            const playerWhoWentOut = finalScores.find(p => p.wentOut);
            if (playerWhoWentOut) {
                playerWhoWentOut.finalScore += totalRackValue;
            }

            // Sort by final score
            finalScores.sort((a, b) => b.finalScore - a.finalScore);

            // Mark winner
            finalScores.forEach((player, index) => {
                player.isWinner = index === 0;
            });

            // Render
            elements.finalScores.innerHTML = '<h3>Final Scores</h3>';
            finalScores.forEach((player, index) => {
                const item = document.createElement('div');
                item.className = 'final-score-item' + (index === 0 ? ' winner' : '');

                const rankSpan = document.createElement('span');
                rankSpan.className = 'final-rank';
                rankSpan.textContent = `${index + 1}.`;

                const nameSpan = document.createElement('span');
                nameSpan.className = 'final-name';
                nameSpan.textContent = player.name + (player.playerId === localState.playerId ? ' (you)' : '');

                const pointsSpan = document.createElement('span');
                pointsSpan.className = 'final-points';
                pointsSpan.textContent = player.finalScore;

                item.appendChild(rankSpan);
                item.appendChild(nameSpan);
                item.appendChild(pointsSpan);
                elements.finalScores.appendChild(item);
            });

            elements.winnerAnnouncement.textContent = finalScores[0].name + ' wins!';

            // Save to gallery (only once per game, check if already saved)
            const galleryGames = getGalleryGames();
            const alreadySaved = galleryGames.some(g => g.roomCode === localState.roomCode);
            if (!alreadySaved) {
                saveFinishedGame(finalScores);
            }
        }

        function updateChallengePending() {
            const challenge = gameState?.pendingChallenge;
            const resultModal = document.getElementById('challenge-result-modal');

            if (!challenge || !challenge.result) {
                resultModal.classList.remove('active');
                return;
            }

            // Show the result modal
            resultModal.classList.add('active');

            // Update verdict display
            const verdictEl = document.getElementById('challenge-verdict');
            const isValid = challenge.result === 'valid';
            verdictEl.className = 'challenge-verdict ' + (isValid ? 'valid' : 'invalid');
            verdictEl.textContent = isValid
                ? '✓ VALID WORD' + (challenge.words.length > 1 ? 'S' : '')
                : '✗ INVALID: ' + challenge.invalidWords.join(', ');

            // Show definitions
            const defsContainer = document.getElementById('challenge-definitions');
            defsContainer.innerHTML = '';
            for (const word of challenge.words) {
                const def = challenge.definitions?.[word];
                const wordDiv = document.createElement('div');
                wordDiv.className = 'word-definition';

                const wordHeader = document.createElement('h4');
                wordHeader.textContent = word.toUpperCase();
                wordDiv.appendChild(wordHeader);

                if (def && def.meanings?.length > 0) {
                    def.meanings.forEach(m => {
                        const p = document.createElement('p');
                        const posSpan = document.createElement('span');
                        posSpan.className = 'part-of-speech';
                        posSpan.textContent = m.partOfSpeech;
                        p.appendChild(posSpan);
                        p.appendChild(document.createTextNode(': ' + m.definition));
                        wordDiv.appendChild(p);
                    });
                } else {
                    const noDefP = document.createElement('p');
                    noDefP.style.color = '#888';
                    noDefP.textContent = 'No definition available';
                    wordDiv.appendChild(noDefP);
                }
                defsContainer.appendChild(wordDiv);
            }

            // Update acknowledgment status
            const acks = challenge.acknowledgments || {};
            const playerIds = gameState.playerOrder || [];
            const ackListEl = document.getElementById('ack-player-list');
            ackListEl.innerHTML = '';

            // Reset the header text
            document.getElementById('acknowledgment-status').querySelector('h4').textContent =
                'Waiting for all players to acknowledge...';

            for (const playerId of playerIds) {
                const player = gameState.players[playerId];
                const hasAcked = acks[playerId];
                const ackDiv = document.createElement('div');
                ackDiv.className = 'ack-player' + (hasAcked ? ' acknowledged' : '');

                const nameSpan = document.createElement('span');
                nameSpan.textContent = (player?.name || 'Player') + (playerId === localState.playerId ? ' (you)' : '');

                const iconSpan = document.createElement('span');
                iconSpan.className = 'ack-icon';
                iconSpan.textContent = hasAcked ? '✓' : '...';

                ackDiv.appendChild(nameSpan);
                ackDiv.appendChild(iconSpan);
                ackListEl.appendChild(ackDiv);
            }

            // Show/hide acknowledge button based on whether current player has acknowledged
            const ackBtn = document.getElementById('acknowledge-btn');
            const hasAcked = acks[localState.playerId];
            ackBtn.style.display = hasAcked ? 'none' : 'inline-block';
            ackBtn.textContent = 'I Acknowledge';

            // Check if all acknowledged (auto-resolve)
            const allAcknowledged = playerIds.every(id => acks[id]);
            if (allAcknowledged) {
                // Will be resolved by checkAllAcknowledged
                document.getElementById('acknowledgment-status').querySelector('h4').textContent =
                    'All players acknowledged! Resolving...';
            }
        }

        // ============================================
        // EVENT HANDLERS
        // ============================================

        // Validate player name: 1-20 chars, alphanumeric + spaces/hyphens/underscores
        function validatePlayerName(name) {
            if (!name) {
                return 'Please enter your name';
            }
            if (name.length > 20) {
                return 'Name must be 20 characters or less';
            }
            if (!/^[a-zA-Z0-9 _-]+$/.test(name)) {
                return 'Name can only contain letters, numbers, spaces, hyphens, and underscores';
            }
            return null; // valid
        }

        document.getElementById('create-game-btn').onclick = async () => {
            const name = elements.playerNameInput.value.trim();
            const validationError = validatePlayerName(name);
            if (validationError) {
                elements.menuError.textContent = validationError;
                return;
            }
            elements.menuError.textContent = '';
            localState.playerName = name;

            try {
                await firebaseCreateGame(name);
            } catch (err) {
                elements.menuError.textContent = err.message;
            }
        };

        document.getElementById('join-game-btn').onclick = async () => {
            const name = elements.playerNameInput.value.trim();
            const code = elements.roomCodeInput.value.trim().toUpperCase();
            const validationError = validatePlayerName(name);
            if (validationError) {
                elements.menuError.textContent = validationError;
                return;
            }
            if (!code || code.length !== 4) {
                elements.menuError.textContent = 'Please enter a 4-letter room code';
                return;
            }
            elements.menuError.textContent = '';
            localState.playerName = name;

            try {
                await firebaseJoinGame(code, name);
            } catch (err) {
                elements.menuError.textContent = err.message;
            }
        };

        document.getElementById('start-game-btn').onclick = async () => {
            try {
                await firebaseStartGame();
            } catch (err) {
                showError(err.message);
            }
        };

        document.getElementById('leave-lobby-btn').onclick = async () => {
            await firebaseLeaveGame();
            showScreen('menu');
        };

        document.getElementById('view-gallery-btn').onclick = () => {
            renderGallery();
            showScreen('gallery');
        };

        document.getElementById('gallery-back-btn').onclick = () => {
            showScreen('menu');
        };

        document.getElementById('recall-btn').onclick = recallTiles;
        document.getElementById('shuffle-btn').onclick = shuffleRack;

        document.getElementById('play-btn').onclick = async () => {
            const result = attemptPlay();
            if (!result) return;

            try {
                await firebasePlayWord(result);
            } catch (err) {
                showError(err.message);
            }
        };

        document.getElementById('pass-btn').onclick = async () => {
            if (!isMyTurn()) return;

            // Confirm before passing
            if (!confirm('Are you sure you want to pass your turn?')) {
                return;
            }

            recallTiles();
            try {
                await firebasePassTurn();
            } catch (err) {
                showError(err.message);
            }
        };

        document.getElementById('swap-btn').onclick = async () => {
            if (!isMyTurn()) return;

            // For simplicity, swap all placed tiles (or selected tile if none placed)
            // In a full implementation, you'd have a swap mode UI
            const tilesToSwap = localState.placedTiles.map(t => t.rackIndex);
            if (tilesToSwap.length === 0) {
                showError('Select tiles to swap by placing them, then click Swap');
                return;
            }

            // Confirm before swapping
            const tileCount = tilesToSwap.length;
            if (!confirm(`Swap ${tileCount} tile${tileCount > 1 ? 's' : ''}? This will end your turn.`)) {
                return;
            }

            recallTiles();
            try {
                await firebaseSwapTiles(tilesToSwap);
            } catch (err) {
                showError(err.message);
            }
        };

        // Challenge button - show confirmation modal
        document.getElementById('challenge-btn').onclick = () => {
            if (!gameState?.lastPlay?.words?.length) return;
            const words = gameState.lastPlay.words;
            document.getElementById('confirm-challenge-words').textContent = `"${words.join('", "')}"`;
            document.getElementById('challenge-confirm-modal').classList.add('active');
        };

        // Cancel challenge
        document.getElementById('confirm-challenge-no').onclick = () => {
            document.getElementById('challenge-confirm-modal').classList.remove('active');
        };

        // Confirm challenge - look up words and show result
        document.getElementById('confirm-challenge-yes').onclick = async () => {
            document.getElementById('challenge-confirm-modal').classList.remove('active');
            try {
                await executeChallenge();
            } catch (err) {
                showError(err.message);
            }
        };

        document.getElementById('accept-word-btn').onclick = async () => {
            // Mark the word as accepted (no longer challengeable)
            if (!gameRef || !gameState?.lastPlay?.challengeable) return;
            try {
                await update(gameRef, { 'lastPlay/challengeable': false });
            } catch (err) {
                console.error('Error accepting word:', err);
            }
        };

        // Acknowledge challenge result
        document.getElementById('acknowledge-btn').onclick = async () => {
            try {
                await firebaseAcknowledgeChallenge();
            } catch (err) {
                showError(err.message);
            }
        };

        document.getElementById('play-again-btn').onclick = async () => {
            await firebaseLeaveGame();
            showScreen('menu');
        };

        document.getElementById('back-to-menu-btn').onclick = async () => {
            await firebaseLeaveGame();
            showScreen('menu');
        };

        // ============================================
        // FIREBASE FUNCTIONS
        // ============================================

        function generateRoomCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
            let code = '';
            for (let i = 0; i < 4; i++) {
                code += chars[Math.floor(Math.random() * chars.length)];
            }
            return code;
        }

        function generatePlayerId() {
            return 'p_' + Math.random().toString(36).substr(2, 9);
        }

        // localStorage helpers for game persistence
        const STORAGE_KEY = 'scrabble_sessions';

        function getSavedSessions() {
            try {
                return JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
            } catch {
                return {};
            }
        }

        function saveSession(roomCode, playerId, playerName, extraData = {}) {
            const sessions = getSavedSessions();
            sessions[roomCode] = {
                playerId,
                playerName,
                lastPlayed: Date.now(),
                ...extraData
            };
            // Keep only the 10 most recent sessions
            const sorted = Object.entries(sessions)
                .sort((a, b) => b[1].lastPlayed - a[1].lastPlayed)
                .slice(0, 10);
            localStorage.setItem(STORAGE_KEY, JSON.stringify(Object.fromEntries(sorted)));
        }

        function updateSessionFromGameState() {
            if (!localState.roomCode || !localState.playerId || !gameState) return;

            const allPlayerNames = Object.values(gameState.players || {}).map(p => p.name);
            const myName = gameState.players?.[localState.playerId]?.name || localState.playerName;

            saveSession(localState.roomCode, localState.playerId, myName, {
                allPlayers: allPlayerNames,
                status: gameState.status
            });
        }

        function getSession(roomCode) {
            const sessions = getSavedSessions();
            return sessions[roomCode] || null;
        }

        function removeSession(roomCode) {
            const sessions = getSavedSessions();
            delete sessions[roomCode];
            localStorage.setItem(STORAGE_KEY, JSON.stringify(sessions));
        }

        function renderRecentGames() {
            const sessions = getSavedSessions();
            const entries = Object.entries(sessions).sort((a, b) => b[1].lastPlayed - a[1].lastPlayed);

            const section = document.getElementById('recent-games-section');
            const list = document.getElementById('recent-games-list');

            if (entries.length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';
            list.innerHTML = '';

            for (const [roomCode, session] of entries) {
                const item = document.createElement('div');
                item.className = 'recent-game-item';

                const timeAgo = getTimeAgo(session.lastPlayed);
                const allPlayers = session.allPlayers || [session.playerName];
                const playerList = allPlayers.join(', ');
                const statusBadge = session.status === 'finished' ? ' (finished)' :
                                   session.status === 'playing' ? ' (in progress)' : '';

                item.innerHTML = `
                    <div class="recent-game-info">
                        <div class="recent-game-code">${roomCode}${statusBadge}</div>
                        <div class="recent-game-players">${playerList}</div>
                        <div class="recent-game-details">You: ${session.playerName} • ${timeAgo}</div>
                    </div>
                    <button class="recent-game-remove" title="Remove">&times;</button>
                `;

                // Click on item to rejoin
                item.querySelector('.recent-game-info').addEventListener('click', () => {
                    document.getElementById('room-code-input').value = roomCode;
                    document.getElementById('player-name').value = session.playerName;
                    document.getElementById('join-game-btn').click();
                });

                // Click X to remove
                item.querySelector('.recent-game-remove').addEventListener('click', (e) => {
                    e.stopPropagation();
                    removeSession(roomCode);
                    renderRecentGames();
                });

                list.appendChild(item);
            }
        }

        function getTimeAgo(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);
            if (seconds < 60) return 'just now';
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}h ago`;
            const days = Math.floor(hours / 24);
            if (days === 1) return 'yesterday';
            if (days < 7) return `${days}d ago`;
            return new Date(timestamp).toLocaleDateString();
        }

        // ============================================
        // GALLERY FUNCTIONS
        // ============================================

        const GALLERY_KEY = 'scrabble_gallery';

        function getGalleryGames() {
            try {
                return JSON.parse(localStorage.getItem(GALLERY_KEY) || '[]');
            } catch {
                return [];
            }
        }

        function saveToGallery(gameData) {
            const gallery = getGalleryGames();
            gallery.unshift(gameData);
            // Keep only last 20 games
            localStorage.setItem(GALLERY_KEY, JSON.stringify(gallery.slice(0, 20)));
        }

        function removeFromGallery(index) {
            const gallery = getGalleryGames();
            gallery.splice(index, 1);
            localStorage.setItem(GALLERY_KEY, JSON.stringify(gallery));
        }

        function captureBoardImage() {
            const canvas = document.createElement('canvas');
            const cellSize = 24;
            const boardSize = 15 * cellSize;
            canvas.width = boardSize;
            canvas.height = boardSize;
            const ctx = canvas.getContext('2d');

            // Draw board
            for (let row = 0; row < 15; row++) {
                for (let col = 0; col < 15; col++) {
                    const x = col * cellSize;
                    const y = row * cellSize;
                    const key = `${row},${col}`;
                    const tile = gameState.board?.[key];

                    // Background color
                    let bgColor = '#d4b896'; // normal
                    const squareType = getSquareType(row, col);
                    if (squareType === 'TW') bgColor = '#ff4444';
                    else if (squareType === 'DW' || squareType === 'center') bgColor = '#ffaaaa';
                    else if (squareType === 'TL') bgColor = '#4444ff';
                    else if (squareType === 'DL') bgColor = '#aaaaff';

                    if (tile) bgColor = '#f5deb3'; // tile color

                    ctx.fillStyle = bgColor;
                    ctx.fillRect(x, y, cellSize, cellSize);
                    ctx.strokeStyle = '#000';
                    ctx.strokeRect(x, y, cellSize, cellSize);

                    // Draw letter
                    if (tile) {
                        ctx.fillStyle = tile.isBlank ? '#666' : '#000';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(tile.letter, x + cellSize/2, y + cellSize/2);

                        // Draw score
                        if (!tile.isBlank) {
                            ctx.font = '8px Arial';
                            ctx.fillText(TILE_SCORES[tile.letter], x + cellSize - 6, y + cellSize - 4);
                        }
                    }
                }
            }

            return canvas.toDataURL('image/png');
        }

        function saveFinishedGame(finalScores) {
            const screenshot = captureBoardImage();
            const gameData = {
                roomCode: localState.roomCode,
                date: Date.now(),
                players: finalScores.map(p => ({
                    name: p.name,
                    score: p.finalScore,
                    isWinner: p.isWinner
                })),
                screenshot
            };
            saveToGallery(gameData);
        }

        function renderGallery() {
            const gallery = getGalleryGames();
            const container = document.getElementById('gallery-games');

            if (gallery.length === 0) {
                container.innerHTML = '<p style="color: #888; text-align: center;">No finished games yet.</p>';
                return;
            }

            container.innerHTML = '';
            gallery.forEach((game, index) => {
                const item = document.createElement('div');
                item.className = 'gallery-item';

                const winner = game.players.find(p => p.isWinner);
                const playerScores = game.players
                    .sort((a, b) => b.score - a.score)
                    .map(p => `${p.name}: ${p.score}`)
                    .join(', ');

                item.innerHTML = `
                    <img src="${game.screenshot}" alt="Game ${game.roomCode}" class="gallery-screenshot">
                    <div class="gallery-info">
                        <div class="gallery-winner">${winner ? winner.name + ' wins!' : 'Game finished'}</div>
                        <div class="gallery-scores">${playerScores}</div>
                        <div class="gallery-date">${new Date(game.date).toLocaleDateString()}</div>
                    </div>
                    <button class="gallery-remove" data-index="${index}">&times;</button>
                `;

                container.appendChild(item);
            });

            // Add remove handlers
            container.querySelectorAll('.gallery-remove').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    removeFromGallery(parseInt(btn.dataset.index));
                    renderGallery();
                };
            });
        }

        function createTileBag() {
            const bag = [];
            for (const [letter, count] of Object.entries(TILE_DISTRIBUTION)) {
                for (let i = 0; i < count; i++) {
                    bag.push(letter);
                }
            }
            // Shuffle
            for (let i = bag.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [bag[i], bag[j]] = [bag[j], bag[i]];
            }
            return bag;
        }

        async function firebaseCreateGame(playerName) {
            const roomCode = generateRoomCode();
            const playerId = generatePlayerId();

            localState.playerId = playerId;
            localState.roomCode = roomCode;
            localState.isHost = true;

            const initialState = {
                roomCode,
                status: 'waiting',
                created: Date.now(),
                hostId: playerId,
                playerOrder: [playerId],
                players: {
                    [playerId]: {
                        name: playerName,
                        score: 0,
                        rack: [],
                        connected: true
                    }
                },
                currentTurn: playerId,
                turnIndex: 0,
                board: {},
                tileBag: [],
                tilesRemaining: 100,
                turnNumber: 0,
                consecutivePasses: 0,
                lastPlay: null,
                pendingChallenge: null
            };

            gameRef = ref(database, `scrabble/${roomCode}`);
            await set(gameRef, initialState);

            // Save session for later reconnection
            saveSession(roomCode, playerId, playerName);

            // Set up presence
            const presenceRef = ref(database, `scrabble/${roomCode}/players/${playerId}/connected`);
            onDisconnect(presenceRef).set(false);

            // Subscribe to changes
            subscribeToGame();
        }

        async function firebaseJoinGame(roomCode, playerName) {
            gameRef = ref(database, `scrabble/${roomCode}`);
            const snapshot = await get(gameRef);

            if (!snapshot.exists()) {
                // Game doesn't exist - remove any stale session
                removeSession(roomCode);
                throw new Error('Game not found');
            }

            const game = snapshot.val();

            // Check for stored session first (most reliable reconnection method)
            const savedSession = getSession(roomCode);
            if (savedSession && game.players?.[savedSession.playerId]) {
                // We have a stored session and the player still exists in the game
                const existingPlayerId = savedSession.playerId;
                localState.playerId = existingPlayerId;
                localState.roomCode = roomCode;
                localState.isHost = existingPlayerId === game.hostId;
                localState.playerName = game.players[existingPlayerId].name;

                // Mark as connected
                await update(gameRef, {
                    [`players/${existingPlayerId}/connected`]: true
                });

                // Update session timestamp
                saveSession(roomCode, existingPlayerId, game.players[existingPlayerId].name);

                // Set up presence
                const presenceRef = ref(database, `scrabble/${roomCode}/players/${existingPlayerId}/connected`);
                onDisconnect(presenceRef).set(false);

                // Subscribe to changes
                subscribeToGame();
                return;
            }

            // No stored session - check game status
            if (game.status === 'finished') {
                throw new Error('Game already finished');
            }

            if (game.status === 'playing') {
                // Game in progress - try to reconnect by name matching
                const disconnectedPlayer = Object.entries(game.players || {}).find(
                    ([id, player]) => player.name.toLowerCase() === playerName.toLowerCase() && !player.connected
                );

                if (disconnectedPlayer) {
                    // Reconnect as this player
                    const [existingPlayerId, player] = disconnectedPlayer;
                    localState.playerId = existingPlayerId;
                    localState.roomCode = roomCode;
                    localState.isHost = existingPlayerId === game.hostId;
                    localState.playerName = player.name;

                    // Mark as connected
                    await update(gameRef, {
                        [`players/${existingPlayerId}/connected`]: true
                    });

                    // Save session for future reconnection
                    saveSession(roomCode, existingPlayerId, player.name);

                    // Set up presence
                    const presenceRef = ref(database, `scrabble/${roomCode}/players/${existingPlayerId}/connected`);
                    onDisconnect(presenceRef).set(false);

                    // Subscribe to changes
                    subscribeToGame();
                    return;
                } else {
                    // No matching disconnected player
                    throw new Error('Game in progress. To rejoin, use the same device or enter your exact name.');
                }
            }

            // Game is waiting - check if player with same name exists (reconnecting)
            const existingPlayer = Object.entries(game.players || {}).find(
                ([id, player]) => player.name.toLowerCase() === playerName.toLowerCase()
            );

            if (existingPlayer) {
                // Reconnect as existing player in lobby
                const [existingPlayerId, player] = existingPlayer;
                localState.playerId = existingPlayerId;
                localState.roomCode = roomCode;
                localState.isHost = existingPlayerId === game.hostId;
                localState.playerName = player.name;

                // Mark as connected
                await update(gameRef, {
                    [`players/${existingPlayerId}/connected`]: true
                });

                // Save session for future reconnection
                saveSession(roomCode, existingPlayerId, player.name);

                // Set up presence
                const presenceRef = ref(database, `scrabble/${roomCode}/players/${existingPlayerId}/connected`);
                onDisconnect(presenceRef).set(false);

                // Subscribe to changes
                subscribeToGame();
                return;
            }

            // New player joining
            const playerCount = game.playerOrder?.length || 0;
            if (playerCount >= 4) {
                throw new Error('Game is full');
            }

            const playerId = generatePlayerId();
            localState.playerId = playerId;
            localState.roomCode = roomCode;
            localState.isHost = false;
            localState.playerName = playerName;

            const updates = {};
            updates[`players/${playerId}`] = {
                name: playerName,
                score: 0,
                rack: [],
                connected: true
            };
            updates['playerOrder'] = [...game.playerOrder, playerId];

            await update(gameRef, updates);

            // Save session for future reconnection
            saveSession(roomCode, playerId, playerName);

            // Set up presence
            const presenceRef = ref(database, `scrabble/${roomCode}/players/${playerId}/connected`);
            onDisconnect(presenceRef).set(false);

            // Subscribe to changes
            subscribeToGame();
        }

        async function firebaseStartGame() {
            if (!gameRef || !localState.isHost) return;

            const snapshot = await get(gameRef);
            const game = snapshot.val();

            if (game.playerOrder.length < 2) {
                showError('Need at least 2 players');
                return;
            }

            // Create and shuffle tile bag
            const tileBag = createTileBag();

            const updates = {
                status: 'playing',
                turnNumber: 1,
                tileBag: tileBag
            };

            // Draw 7 tiles for each player
            let bagIndex = 0;
            for (const playerId of game.playerOrder) {
                const rack = tileBag.slice(bagIndex, bagIndex + 7);
                bagIndex += 7;
                updates[`players/${playerId}/rack`] = rack;
            }
            updates.tileBag = tileBag.slice(bagIndex);
            updates.tilesRemaining = tileBag.length - bagIndex;

            await update(gameRef, updates);
        }

        // Helper to get next player, handling skipNextTurn
        function getNextPlayer(game, currentTurnIndex) {
            const playerOrder = game.playerOrder;
            const playerCount = playerOrder.length;
            let nextIndex = (currentTurnIndex + 1) % playerCount;
            let skippedPlayer = null;

            // Check if the next player should be skipped
            const nextPlayerId = playerOrder[nextIndex];
            if (game.players[nextPlayerId]?.skipNextTurn) {
                skippedPlayer = nextPlayerId;
                nextIndex = (nextIndex + 1) % playerCount;
            }

            return {
                playerId: playerOrder[nextIndex],
                index: nextIndex,
                skippedPlayer: skippedPlayer
            };
        }

        async function firebasePlayWord(result) {
            if (!gameRef) return;

            const snapshot = await get(gameRef);
            const game = snapshot.val();

            const updates = {};

            // Add tiles to board
            for (const tile of result.tiles) {
                updates[`board/${tile.row},${tile.col}`] = {
                    letter: tile.letter,
                    isBlank: tile.isBlank,
                    turnPlayed: game.turnNumber
                };
            }

            // Update player score
            const currentScore = game.players[localState.playerId].score || 0;
            updates[`players/${localState.playerId}/score`] = currentScore + result.score;

            // Remove played tiles from rack and draw new ones
            const playedIndices = localState.placedTiles.map(t => t.rackIndex).sort((a, b) => b - a);
            const rack = [...game.players[localState.playerId].rack];
            for (const idx of playedIndices) {
                rack.splice(idx, 1);
            }

            // Draw new tiles
            const tileBag = game.tileBag || [];
            const tilesToDraw = Math.min(7 - rack.length, tileBag.length);
            const drawnTiles = [];
            for (let i = 0; i < tilesToDraw; i++) {
                const tile = tileBag.shift();
                drawnTiles.push(tile);
                rack.push(tile);
            }
            updates[`players/${localState.playerId}/rack`] = rack;
            updates.tileBag = tileBag;
            updates.tilesRemaining = tileBag.length;

            // Advance turn (check for skipped players)
            const nextTurn = getNextPlayer(game, game.turnIndex);
            updates.currentTurn = nextTurn.playerId;
            updates.turnIndex = nextTurn.index;
            if (nextTurn.skippedPlayer) {
                updates[`players/${nextTurn.skippedPlayer}/skipNextTurn`] = null;
            }
            updates.turnNumber = game.turnNumber + 1;
            updates.consecutivePasses = 0;

            // Record last play (include drawn tiles for challenge reversal)
            updates.lastPlay = {
                player: localState.playerId,
                words: result.words,
                score: result.score,
                tiles: result.tiles,
                drawnTiles: drawnTiles,
                turnNumber: game.turnNumber,
                challengeable: true
            };

            // Check for game end (player used all tiles and bag empty)
            if (rack.length === 0 && tileBag.length === 0) {
                updates.status = 'finished';
            }

            await update(gameRef, updates);

            // Clear local state
            localState.placedTiles = [];
            localState.selectedRackIndex = null;
        }

        async function firebasePassTurn() {
            if (!gameRef) return;

            const snapshot = await get(gameRef);
            const game = snapshot.val();

            const playerCount = game.playerOrder.length;
            const newConsecutivePasses = (game.consecutivePasses || 0) + 1;

            const updates = {};

            // Advance turn (check for skipped players)
            const nextTurn = getNextPlayer(game, game.turnIndex);
            updates.currentTurn = nextTurn.playerId;
            updates.turnIndex = nextTurn.index;
            if (nextTurn.skippedPlayer) {
                updates[`players/${nextTurn.skippedPlayer}/skipNextTurn`] = null;
            }
            updates.consecutivePasses = newConsecutivePasses;

            // Mark last play as not challengeable
            if (game.lastPlay) {
                updates['lastPlay/challengeable'] = false;
            }

            // Game ends if all players pass consecutively
            if (newConsecutivePasses >= playerCount) {
                updates.status = 'finished';
            }

            await update(gameRef, updates);

            // Clear local placed tiles
            localState.placedTiles = [];
            localState.selectedRackIndex = null;
        }

        async function firebaseSwapTiles(indicesToSwap) {
            if (!gameRef || indicesToSwap.length === 0) return;

            const snapshot = await get(gameRef);
            const game = snapshot.val();

            const tileBag = game.tileBag || [];
            if (tileBag.length < indicesToSwap.length) {
                showError('Not enough tiles in bag');
                return;
            }

            const rack = [...game.players[localState.playerId].rack];
            const tilesToReturn = indicesToSwap.map(i => rack[i]);

            // Remove swapped tiles from rack (in reverse order to preserve indices)
            for (const idx of indicesToSwap.sort((a, b) => b - a)) {
                rack.splice(idx, 1);
            }

            // Draw new tiles
            const newTiles = tileBag.splice(0, tilesToReturn.length);
            rack.push(...newTiles);

            // Return swapped tiles to bag and shuffle
            tileBag.push(...tilesToReturn);
            for (let i = tileBag.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [tileBag[i], tileBag[j]] = [tileBag[j], tileBag[i]];
            }

            const updates = {};
            updates[`players/${localState.playerId}/rack`] = rack;
            updates.tileBag = tileBag;

            // Advance turn (swap counts as a pass for consecutive pass counting)
            const nextTurn = getNextPlayer(game, game.turnIndex);
            updates.currentTurn = nextTurn.playerId;
            updates.turnIndex = nextTurn.index;
            if (nextTurn.skippedPlayer) {
                updates[`players/${nextTurn.skippedPlayer}/skipNextTurn`] = null;
            }
            updates.consecutivePasses = (game.consecutivePasses || 0) + 1;

            if (game.lastPlay) {
                updates['lastPlay/challengeable'] = false;
            }

            await update(gameRef, updates);

            localState.placedTiles = [];
            localState.selectedRackIndex = null;
        }

        // Fetch word definition from free dictionary API
        async function fetchWordDefinition(word) {
            try {
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word.toLowerCase()}`);
                if (!response.ok) return null;
                const data = await response.json();
                if (!Array.isArray(data) || data.length === 0) return null;

                const entry = data[0];
                const meanings = entry.meanings?.slice(0, 2).map(m => ({
                    partOfSpeech: m.partOfSpeech,
                    definition: m.definitions?.[0]?.definition || ''
                })) || [];

                return { word: entry.word, meanings };
            } catch (err) {
                console.error('Error fetching definition:', err);
                return null;
            }
        }

        // Execute challenge: look up words, determine validity, store result
        async function executeChallenge() {
            if (!gameRef || !gameState?.lastPlay?.challengeable) return;

            const words = gameState.lastPlay.words || [];
            const invalidWords = [];
            const definitions = {};

            // Check each word against dictionary
            for (const word of words) {
                const isValid = SCRABBLE_DICTIONARY.has(word.toUpperCase());
                if (!isValid) {
                    invalidWords.push(word);
                }
                // Fetch definition for display (even if invalid, might still have one)
                const def = await fetchWordDefinition(word);
                if (def) {
                    definitions[word] = def;
                }
            }

            const challengeSucceeded = invalidWords.length > 0;

            // Create pending challenge with result
            const updates = {
                pendingChallenge: {
                    challengedPlayer: gameState.lastPlay.player,
                    challenger: localState.playerId,
                    turnNumber: gameState.lastPlay.turnNumber,
                    words: gameState.lastPlay.words,
                    tiles: gameState.lastPlay.tiles,
                    drawnTiles: gameState.lastPlay.drawnTiles || [],
                    score: gameState.lastPlay.score,
                    // New fields for automatic resolution
                    result: challengeSucceeded ? 'invalid' : 'valid',
                    invalidWords: invalidWords,
                    definitions: definitions,
                    acknowledgments: { [localState.playerId]: true }  // Challenger auto-acknowledges
                },
                'lastPlay/challengeable': false
            };

            await update(gameRef, updates);
        }

        // Acknowledge challenge result
        async function firebaseAcknowledgeChallenge() {
            if (!gameRef || !gameState?.pendingChallenge) return;

            const updates = {
                [`pendingChallenge/acknowledgments/${localState.playerId}`]: true
            };

            await update(gameRef, updates);

            // Check if all players have acknowledged
            await checkAllAcknowledged();
        }

        // Check if all players acknowledged and resolve if so
        async function checkAllAcknowledged() {
            if (!gameState?.pendingChallenge) return;

            const challenge = gameState.pendingChallenge;
            const acks = challenge.acknowledgments || {};
            const playerIds = gameState.playerOrder || [];

            const allAcknowledged = playerIds.every(id => acks[id]);

            if (allAcknowledged) {
                await resolveChallenge(challenge.result === 'invalid');
            }
        }

        // Resolve the challenge after all players acknowledge
        async function resolveChallenge(challengeSucceeded) {
            if (!gameRef || !gameState?.pendingChallenge) return;

            const challenge = gameState.pendingChallenge;
            const updates = { pendingChallenge: null };

            if (challengeSucceeded) {
                // Word was invalid - remove it from board
                for (const tile of challenge.tiles) {
                    updates[`board/${tile.row},${tile.col}`] = null;
                }

                // Get current rack and remove the drawn tiles, then add back played tiles
                let challengedRack = [...gameState.players[challenge.challengedPlayer].rack];
                const drawnTiles = challenge.drawnTiles || [];

                // Remove drawn tiles from rack (find and remove each one)
                for (const tile of drawnTiles) {
                    const idx = challengedRack.indexOf(tile);
                    if (idx !== -1) {
                        challengedRack.splice(idx, 1);
                    }
                }

                // Add played tiles back to rack
                for (const tile of challenge.tiles) {
                    challengedRack.push(tile.originalLetter || tile.letter);
                }
                updates[`players/${challenge.challengedPlayer}/rack`] = challengedRack;

                // Return drawn tiles to the bag
                const tileBag = [...(gameState.tileBag || []), ...drawnTiles];
                // Shuffle the returned tiles into the bag
                for (let i = tileBag.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [tileBag[i], tileBag[j]] = [tileBag[j], tileBag[i]];
                }
                updates.tileBag = tileBag;
                updates.tilesRemaining = tileBag.length;

                // Subtract score (player scores 0 for this turn)
                const currentScore = gameState.players[challenge.challengedPlayer].score || 0;
                updates[`players/${challenge.challengedPlayer}/score`] = currentScore - challenge.score;

                // Turn should already be on the next player (it advanced when word was played)
                // But ensure we don't have any stale skipNextTurn on the challenged player
                updates[`players/${challenge.challengedPlayer}/skipNextTurn`] = null;

            } else {
                // Word was valid - challenger loses next turn
                updates[`players/${challenge.challenger}/skipNextTurn`] = true;
            }

            await update(gameRef, updates);

            // Hide the result modal
            document.getElementById('challenge-result-modal').classList.remove('active');
        }

        async function firebaseLeaveGame() {
            if (unsubscribe) {
                unsubscribe();
                unsubscribe = null;
            }

            if (gameRef && localState.playerId) {
                await update(gameRef, {
                    [`players/${localState.playerId}/connected`]: false
                });
            }

            gameRef = null;
            gameState = null;
            localState = {
                playerId: null,
                playerName: '',
                roomCode: null,
                selectedRackIndex: null,
                placedTiles: [],
                isHost: false
            };
        }

        function subscribeToGame() {
            if (unsubscribe) unsubscribe();

            unsubscribe = onValue(gameRef, (snapshot) => {
                if (snapshot.exists()) {
                    onGameStateUpdate(snapshot.val());
                }
            });
        }

        // ============================================
        // INITIALIZATION
        // ============================================

        createBoard();
        renderRecentGames();
    </script>
    <script type="module" src="js/analytics.js"></script>
</body>
</html>
