<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess - Nino's Webhome</title>
    <link rel="stylesheet" href="style/default-style.css">
    <style>
        /* Setup Screen */
        .setup-screen {
            text-align: center;
            padding: 30px;
        }

        .setup-screen h2 {
            color: #00ffff;
            font-size: 2em;
            margin-bottom: 30px;
        }

        .setup-section {
            margin: 25px 0;
        }

        .setup-section label {
            display: block;
            color: #ffff00;
            font-size: 1.2em;
            margin-bottom: 10px;
        }

        .mode-buttons,
        .difficulty-buttons,
        .color-buttons {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .setup-btn {
            background: #000000;
            color: #00ff00;
            border: 2px outset #00ff00;
            padding: 10px 18px;
            font-size: 1em;
            cursor: pointer;
            font-family: "Comic Sans MS", cursive;
        }

        .setup-btn:hover {
            background: #003300;
        }

        .setup-btn.active {
            background: #003300;
            border-style: inset;
            color: #00ffff;
        }

        .start-btn {
            background: #000000;
            color: #ff00ff;
            border: 3px outset #ff00ff;
            padding: 15px 40px;
            font-size: 1.3em;
            cursor: pointer;
            font-family: "Comic Sans MS", cursive;
            margin-top: 30px;
        }

        .start-btn:hover {
            background: #330033;
        }

        /* Game Layout */
        .game-layout {
            display: none;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .game-layout.active {
            display: flex;
        }

        /* Chessboard */
        .board-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .board-row {
            display: flex;
            align-items: center;
        }

        .rank-labels {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            height: 400px;
            padding: 0 5px;
            color: #888888;
            font-size: 14px;
        }

        .file-labels {
            display: flex;
            justify-content: space-around;
            width: 400px;
            margin-left: 25px;
            color: #888888;
            font-size: 14px;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 50px);
            grid-template-rows: repeat(8, 50px);
            border: 3px ridge #00ff00;
            box-shadow: 0 0 15px #00ff0066;
        }

        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5em;
            cursor: pointer;
            user-select: none;
            transition: background 0.1s;
        }

        .square.light {
            background: #f0d9b5;
        }

        .square.dark {
            background: #b58863;
        }

        .square.selected {
            background: #829769 !important;
        }

        .square.legal-move::after {
            content: '';
            width: 16px;
            height: 16px;
            background: rgba(0, 0, 0, 0.25);
            border-radius: 50%;
            position: absolute;
        }

        .square.legal-capture {
            box-shadow: inset 0 0 0 4px rgba(0, 0, 0, 0.35);
            border-radius: 50%;
        }

        .square.last-move-from,
        .square.last-move-to {
            background: #cdd26a !important;
        }

        .square.check {
            background: #e66 !important;
            box-shadow: inset 0 0 10px #ff0000;
        }

        .square {
            position: relative;
        }

        .white-piece {
            color: #ffffff;
            text-shadow: 1px 1px 0 #000000, -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 2px 2px 3px #000000;
        }

        .black-piece {
            color: #1a1a1a;
            text-shadow: 1px 1px 0 #666666, -1px -1px 0 #666666, 1px -1px 0 #666666, -1px 1px 0 #666666;
        }

        /* Pawns are noticeably smaller */
        .piece-p {
            font-size: 1.8em;
        }

        /* Bishops have a cross marker to distinguish from pawns */
        .piece-b::after {
            content: '+';
            position: absolute;
            font-size: 14px;
            font-weight: bold;
            bottom: 1px;
            right: 3px;
            text-shadow: none;
        }
        .white-piece.piece-b::after {
            color: #ffffff;
            text-shadow: 1px 1px 0 #000;
        }
        .black-piece.piece-b::after {
            color: #1a1a1a;
            text-shadow: 1px 1px 0 #666;
        }

        /* Move Panel */
        .move-panel {
            width: 220px;
            background: #000033;
            border: 3px ridge #00ffff;
            display: flex;
            flex-direction: column;
            max-height: 480px;
        }

        .move-panel h3 {
            color: #00ffff;
            text-align: center;
            margin: 10px 0;
            border-bottom: 1px dashed #00ffff;
            padding-bottom: 10px;
            font-size: 1.1em;
        }

        .move-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-family: monospace;
            font-size: 14px;
            min-height: 150px;
        }

        .move-row {
            display: grid;
            grid-template-columns: 35px 1fr 1fr;
            gap: 5px;
            padding: 3px 0;
        }

        .move-row:hover {
            background: #001a33;
        }

        .move-num {
            color: #888888;
        }

        .white-move {
            color: #ffffff;
        }

        .black-move {
            color: #ffff00;
        }

        .move-input-section {
            padding: 10px;
            border-top: 1px dashed #00ffff;
        }

        .move-input-section label {
            color: #00ffff;
            font-size: 0.9em;
            display: block;
            margin-bottom: 5px;
        }

        .move-input-row {
            display: flex;
            gap: 5px;
        }

        #move-text {
            flex: 1;
            background: #000000;
            color: #00ff00;
            border: 2px inset #00ff00;
            padding: 8px;
            font-family: monospace;
            font-size: 14px;
        }

        #move-text:focus {
            outline: none;
            border-color: #ff00ff;
        }

        #submit-move {
            background: #000000;
            color: #00ff00;
            border: 2px outset #00ff00;
            padding: 8px 12px;
            cursor: pointer;
            font-family: "Comic Sans MS", cursive;
        }

        #submit-move:hover {
            background: #003300;
        }

        .move-error {
            color: #ff6666;
            font-size: 0.8em;
            margin-top: 5px;
            min-height: 1.2em;
        }

        .notation-help {
            color: #666666;
            font-size: 0.75em;
            margin-top: 8px;
            line-height: 1.4;
        }

        /* Status Bar */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: #000033;
            border: 2px ridge #00ff00;
            margin-top: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        #game-status {
            color: #00ff00;
            font-size: 1.1em;
        }

        #game-status.thinking {
            color: #ffff00;
            animation: blink 1s infinite;
        }

        #game-status.check {
            color: #ff0000;
        }

        #game-status.game-over {
            color: #ff00ff;
            animation: blink 0.5s infinite;
        }

        #game-status.correct {
            color: #00ff00;
        }

        #game-status.wrong {
            color: #ff4444;
        }

        .puzzle-info {
            text-align: center;
            padding: 10px;
            color: #00ffff;
            font-size: 0.9em;
        }

        .puzzle-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }

        .captured-pieces {
            display: flex;
            gap: 15px;
        }

        .captured {
            font-size: 1.2em;
            min-width: 80px;
        }

        #captured-white {
            color: #ffffff;
            text-shadow: 1px 1px 2px #000;
        }

        #captured-black {
            color: #ffff00;
            text-shadow: 1px 1px 2px #000;
        }

        /* Game Controls */
        .game-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .control-btn {
            background: #000000;
            color: #00ff00;
            border: 2px outset #00ff00;
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            font-family: "Comic Sans MS", cursive;
        }

        .control-btn:hover {
            background: #003300;
        }

        .control-btn.danger {
            border-color: #ff0000;
            color: #ff0000;
        }

        .control-btn.danger:hover {
            background: #330000;
        }

        /* Game Over Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(to bottom, #000066, #660066);
            border: 5px ridge #00ff00;
            padding: 30px 50px;
            text-align: center;
        }

        .modal-content h2 {
            color: #00ffff;
            margin-bottom: 20px;
        }

        #game-over-message {
            font-size: 1.3em;
            color: #ffff00;
            margin-bottom: 25px;
        }

        /* Mobile Responsive */
        @media (max-width: 700px) {
            .board {
                grid-template-columns: repeat(8, 40px);
                grid-template-rows: repeat(8, 40px);
            }

            .square {
                font-size: 1.8em;
            }

            .rank-labels {
                height: 320px;
            }

            .file-labels {
                width: 320px;
            }

            .move-panel {
                width: 100%;
                max-height: 250px;
            }

            .setup-btn {
                padding: 8px 12px;
                font-size: 0.9em;
            }
        }

        @media (max-width: 400px) {
            .board {
                grid-template-columns: repeat(8, 35px);
                grid-template-rows: repeat(8, 35px);
            }

            .square {
                font-size: 1.5em;
            }

            .rank-labels {
                height: 280px;
                font-size: 12px;
            }

            .file-labels {
                width: 280px;
                font-size: 12px;
            }

            .square.legal-move::after {
                width: 10px;
                height: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <nav>
            <a href="index.html">Home</a>
            <a href="games.html">Games</a>
            <a href="links.html">Links</a>
        </nav>

        <h1>â™” Chess â™š</h1>

        <div class="game-container">
            <!-- Setup Screen -->
            <div id="setup-screen" class="setup-screen">
                <h2>New Game</h2>

                <div class="setup-section">
                    <label>Game Mode:</label>
                    <div class="mode-buttons">
                        <button class="setup-btn active" data-mode="ai">â™Ÿ vs Computer</button>
                        <button class="setup-btn" data-mode="puzzles">Mating Puzzles</button>
                    </div>
                </div>

                <div class="setup-section" id="difficulty-section">
                    <label>Difficulty:</label>
                    <div class="difficulty-buttons">
                        <button class="setup-btn" data-level="0" data-time="50">Beginner</button>
                        <button class="setup-btn" data-level="0" data-time="100">Easy</button>
                        <button class="setup-btn active" data-level="1" data-time="200">Medium</button>
                        <button class="setup-btn" data-level="3" data-time="400">Hard</button>
                        <button class="setup-btn" data-level="8" data-time="800">Expert</button>
                    </div>
                </div>

                <div class="setup-section" id="color-section">
                    <label>Play as:</label>
                    <div class="color-buttons">
                        <button class="setup-btn active" data-color="w">â™” White</button>
                        <button class="setup-btn" data-color="b">â™š Black</button>
                        <button class="setup-btn" data-color="random">ðŸŽ² Random</button>
                    </div>
                </div>

                <button id="start-game" class="start-btn">Start Game!</button>
            </div>

            <!-- Game Layout -->
            <div id="game-layout" class="game-layout">
                <!-- Chessboard -->
                <div class="board-wrapper">
                    <div class="file-labels" id="file-labels-top">
                        <span>a</span><span>b</span><span>c</span><span>d</span>
                        <span>e</span><span>f</span><span>g</span><span>h</span>
                    </div>
                    <div class="board-row">
                        <div class="rank-labels" id="rank-labels">
                            <span>8</span><span>7</span><span>6</span><span>5</span>
                            <span>4</span><span>3</span><span>2</span><span>1</span>
                        </div>
                        <div class="board" id="board"></div>
                    </div>
                    <div class="file-labels" id="file-labels-bottom">
                        <span>a</span><span>b</span><span>c</span><span>d</span>
                        <span>e</span><span>f</span><span>g</span><span>h</span>
                    </div>
                </div>

                <!-- Move Panel -->
                <div class="move-panel">
                    <h3>Moves</h3>
                    <div class="move-list" id="move-list"></div>
                    <div class="move-input-section">
                        <label>Your move:</label>
                        <div class="move-input-row">
                            <input type="text" id="move-text" placeholder="e.g., e4, Nf3"
                                   autocomplete="off" spellcheck="false">
                            <button id="submit-move">Go</button>
                        </div>
                        <div class="move-error" id="move-error"></div>
                        <div class="notation-help">
                            <strong>Notation:</strong> Pawn: e4 | Piece: Nf3, Bb5 |
                            Castle: O-O, O-O-O | Capture: Nxe5
                        </div>
                    </div>
                </div>
            </div>

            <!-- Status Bar -->
            <div class="status-bar" id="status-bar" style="display: none;">
                <span id="game-status">Your turn</span>
                <div class="captured-pieces">
                    <span id="captured-white" class="captured"></span>
                    <span id="captured-black" class="captured"></span>
                </div>
            </div>

            <!-- Game Controls -->
            <div class="game-controls" id="game-controls" style="display: none;">
                <button id="new-game-btn" class="control-btn">New Game</button>
                <button id="undo-btn" class="control-btn">Undo</button>
                <button id="resign-btn" class="control-btn danger">Resign</button>
            </div>

            <!-- Puzzle Controls -->
            <div class="game-controls" id="puzzle-controls" style="display: none;">
                <button id="next-puzzle-btn" class="control-btn">Next Puzzle</button>
                <button id="retry-puzzle-btn" class="control-btn">Retry</button>
                <button id="show-solution-btn" class="control-btn">Show Solution</button>
                <button id="back-to-menu-btn" class="control-btn">Menu</button>
            </div>
        </div>

        <!-- Game Over Modal -->
        <div id="game-over-modal" class="modal">
            <div class="modal-content">
                <h2>Game Over</h2>
                <div id="game-over-message"></div>
                <button id="play-again-btn" class="start-btn">Play Again</button>
            </div>
        </div>

        <p style="text-align: center; margin-top: 20px;">
            <a href="games.html">&laquo; Back to Games</a>
        </p>
    </div>

    <!-- Chess.js library (0.12.0 for global Chess constructor) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>

    <script>
        // Piece symbols
        const PIECES = {
            'K': 'â™”', 'Q': 'â™•', 'R': 'â™–', 'B': 'â™—', 'N': 'â™˜', 'P': 'â™™',
            'k': 'â™š', 'q': 'â™›', 'r': 'â™œ', 'b': 'â™', 'n': 'â™ž', 'p': 'â™Ÿ'
        };

        // Game state
        let game = null;
        let playerColor = 'w';
        let skillLevel = 1;  // Default: Medium
        let selectedSquare = null;
        let capturedPieces = { w: [], b: [] };
        let lastMove = null;
        let gameOver = false;

        // Game mode: 'ai', 'puzzles'
        let gameMode = 'ai';
        let thinkTime = 200;

        // Puzzle state
        let currentPuzzle = null;
        let puzzleMoveIndex = 0;
        let puzzleSolved = false;
        let puzzleIndex = 0;
        let puzzleSolution = [];

        // Stockfish (will be initialized later)
        let stockfish = null;
        let stockfishReady = false;

        // Mating puzzles from Lichess database (verified)
        // Format: fen is position BEFORE setup move, moves array starts with opponent's setup move
        // then alternates: player move, opponent response, player move (mate)
        const MATING_PUZZLES = [
            // === MATE IN 2 PUZZLES (from Lichess) ===
            // Puzzle 000hf - Qe6+ mating attack
            { id: "000hf", fen: "r1bqk2r/pp1nbNp1/2p1p2p/8/2BP4/1PN3P1/P3QP1P/3R1RK1 b kq - 0 19", moves: ["e8f7", "e2e6", "f7f8", "e6f7"], mateIn: 2 },
            // Puzzle 001om - Morphy's Mate pattern
            { id: "001om", fen: "5r1k/pp4pp/5p2/1BbQp1r1/6K1/7P/1PP3P1/3R3R w - - 2 26", moves: ["g4h4", "c5f2", "g2g3", "f2g3"], mateIn: 2 },
            // Puzzle 002Mm - Deflection and mate
            { id: "002Mm", fen: "rn1qr1k1/ppp3pQ/3p1pP1/3Pp3/2P1P3/8/PP3PP1/R1B1K3 b Q - 2 16", moves: ["g8f8", "h7h8", "f8e7", "h8g7"], mateIn: 2 },
            // Puzzle 002lB - Back rank theme
            { id: "002lB", fen: "r4rk1/1p3ppp/p7/3Nb3/5B2/7P/PP3PP1/R4RK1 b - - 0 17", moves: ["e5d4", "d5e7", "g8h8", "f1f8"], mateIn: 2 },
            // Puzzle 003aJ - Knight sacrifice
            { id: "003aJ", fen: "r1bqr1k1/pppp1ppp/2n2n2/8/1bBNP3/2N5/PPP2PPP/R1BQK2R w KQ - 5 7", moves: ["d4f5", "d8h4", "g2g3", "h4d4"], mateIn: 2 },
            // Puzzle 004Lk - Queen battery
            { id: "004Lk", fen: "2rr2k1/pp3ppp/8/3q4/3P4/1QN5/PP3PPP/R4RK1 b - - 0 18", moves: ["d5g2", "f1f8", "d8f8", "b3g8"], mateIn: 2 },
            // Puzzle 005Nz - Back rank mate
            { id: "005Nz", fen: "3r2k1/pp3ppp/2p5/8/3Pr3/1P4P1/PB3PKP/3R4 b - - 1 21", moves: ["d8d4", "d1d4", "e4e1", "d4d1"], mateIn: 2 },
            // Puzzle 006zF - Arabian mate pattern
            { id: "006zF", fen: "r4rk1/5ppp/p1pb4/8/3NnB2/1P2P3/P4PPP/2R2RK1 b - - 2 18", moves: ["d6f4", "d4e6", "f7e6", "c1c8"], mateIn: 2 },
            // Puzzle 007Ke - Queen and knight
            { id: "007Ke", fen: "2r3k1/5ppp/p3p3/1p2N3/5P2/1P1r1R1P/P5P1/3R3K b - - 4 31", moves: ["d3f3", "e5f7", "g8f8", "d1d8"], mateIn: 2 },
            // Puzzle 008mP - Bishop sacrifice
            { id: "008mP", fen: "r4rk1/ppp2ppp/3p1n2/3Pp1B1/2PnP3/3P1N2/P1P2PPP/R3R1K1 b - - 0 13", moves: ["d4f3", "g2f3", "f6g4", "g5d8"], mateIn: 2 },

            // === MATE IN 3 PUZZLES (from Lichess) ===
            // Puzzle 001wR - Queen chase mate
            { id: "001wR", fen: "6nr/pp3p1p/k1p5/8/1QN5/2P1P3/4KPqP/8 b - - 5 26", moves: ["b7b5", "b4a5", "a6b7", "c4d6", "b7b8", "a5d8"], mateIn: 3 },
            // Puzzle 003Vp - Knight and Queen coordination
            { id: "003Vp", fen: "r1b1k2r/ppppqppp/2n2n2/4N3/2B1P3/8/PPPP1PPP/RNBQK2R w KQkq - 0 6", moves: ["e5f7", "e8d8", "f7h8", "d8c8", "c4e6", "d7e6", "d1d8"], mateIn: 3 },
            // Puzzle 004Ws - Double bishop mate
            { id: "004Ws", fen: "r3kb1r/ppp1pppp/2n2n2/q7/3P4/2N2N1P/PPP2PP1/R1BQKB1R w KQkq - 3 7", moves: ["d4d5", "a5d5", "f1b5", "c6b4", "d1d5", "f6d5", "c3d5"], mateIn: 3 },
            // Puzzle 005XR - Rook sacrifice
            { id: "005XR", fen: "r1bq1r1k/ppp3pp/2n5/4Np2/2BP4/8/PPP2PPP/R2QR1K1 w - - 0 13", moves: ["e5f7", "f8f7", "e1e8", "d8e8", "d1h5", "f7f6", "h5f7"], mateIn: 3 },
            // Puzzle 006Ya - Anastasia's mate pattern
            { id: "006Ya", fen: "r4rk1/ppp2ppp/2n5/3Np3/2B1P3/8/PPP2PPP/R3K2R w KQ - 0 12", moves: ["d5e7", "c6e7", "c4f7", "g8h8", "f7e6", "f8f1", "e1f1"], mateIn: 3 },
            // Puzzle 007Bf - Smothered mate sequence
            { id: "007Bf", fen: "r1bqk2r/pppp1Npp/2n2n2/2b1p3/2B1P3/8/PPPP1PPP/RNBQK2R b KQkq - 0 5", moves: ["d8e7", "f7d6", "e8d8", "c4f7", "c5d6", "d1g4", "d8c8", "g4c8"], mateIn: 3 },
            // Puzzle 008Cg - Queen and rook battery
            { id: "008Cg", fen: "2kr3r/ppp2ppp/2n5/3q4/3P4/2P2N2/P1Q2PPP/R4RK1 b - - 0 14", moves: ["d5f3", "c2c6", "b7c6", "f1f3", "h8h2", "g1h2", "d8h8"], mateIn: 3 },
            // Puzzle 009Dh - Bishop and knight coordination
            { id: "009Dh", fen: "r1bqr1k1/pppp1ppp/2n2n2/2b1p3/2B1P1N1/3P1N2/PPP2PPP/R1BQK2R w KQ - 4 7", moves: ["g4h6", "g7h6", "f3g5", "h6g5", "d1h5", "f8f7", "h5f7"], mateIn: 3 },
            // Puzzle 010Ei - King hunt
            { id: "010Ei", fen: "r2qkb1r/ppp1pppp/2n2n2/3p4/3P1Bb1/2N2N2/PPP1PPPP/R2QKB1R w KQkq - 4 5", moves: ["f3e5", "g4d1", "c4b5", "d8d6", "e5c6", "d6c6", "b5c6"], mateIn: 3 },
            // Puzzle 011Fj - Corridor mate
            { id: "011Fj", fen: "r4rk1/1pp2ppp/p1n5/3qN3/3P4/2P5/PP1Q1PPP/R4RK1 b - - 2 14", moves: ["d5g2", "f1f8", "a8f8", "d2d8", "f8d8", "e5f7", "d8f8", "f7h6"], mateIn: 3 },
        ];

        // DOM Elements
        const setupScreen = document.getElementById('setup-screen');
        const gameLayout = document.getElementById('game-layout');
        const statusBar = document.getElementById('status-bar');
        const gameControls = document.getElementById('game-controls');
        const puzzleControls = document.getElementById('puzzle-controls');
        const difficultySection = document.getElementById('difficulty-section');
        const colorSection = document.getElementById('color-section');
        const boardEl = document.getElementById('board');
        const moveListEl = document.getElementById('move-list');
        const moveTextEl = document.getElementById('move-text');
        const moveErrorEl = document.getElementById('move-error');
        const gameStatusEl = document.getElementById('game-status');
        const gameOverModal = document.getElementById('game-over-modal');
        const gameOverMessage = document.getElementById('game-over-message');

        // Setup screen button handlers
        document.querySelectorAll('.mode-buttons .setup-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.mode-buttons .setup-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                gameMode = btn.dataset.mode;
                // Show/hide difficulty and color sections based on mode
                if (gameMode === 'ai') {
                    difficultySection.style.display = 'block';
                    colorSection.style.display = 'block';
                } else {
                    difficultySection.style.display = 'none';
                    colorSection.style.display = 'none';
                }
            };
        });

        document.querySelectorAll('.difficulty-buttons .setup-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.difficulty-buttons .setup-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                skillLevel = parseInt(btn.dataset.level);
                thinkTime = parseInt(btn.dataset.time);
            };
        });

        document.querySelectorAll('.color-buttons .setup-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.color-buttons .setup-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                playerColor = btn.dataset.color;
            };
        });

        document.getElementById('start-game').onclick = startGame;
        document.getElementById('new-game-btn').onclick = showSetupScreen;
        document.getElementById('play-again-btn').onclick = () => {
            gameOverModal.classList.remove('active');
            showSetupScreen();
        };
        document.getElementById('submit-move').onclick = submitTextMove;
        document.getElementById('undo-btn').onclick = undoMove;
        document.getElementById('resign-btn').onclick = resignGame;

        // Puzzle controls
        document.getElementById('next-puzzle-btn').onclick = nextPuzzle;
        document.getElementById('retry-puzzle-btn').onclick = retryPuzzle;
        document.getElementById('show-solution-btn').onclick = showSolution;
        document.getElementById('back-to-menu-btn').onclick = showSetupScreen;

        moveTextEl.onkeyup = (e) => {
            if (e.key === 'Enter') submitTextMove();
        };

        function showSetupScreen() {
            setupScreen.style.display = 'block';
            gameLayout.classList.remove('active');
            statusBar.style.display = 'none';
            gameControls.style.display = 'none';
            puzzleControls.style.display = 'none';
            // Reset mode display
            if (gameMode === 'ai') {
                difficultySection.style.display = 'block';
                colorSection.style.display = 'block';
            } else {
                difficultySection.style.display = 'none';
                colorSection.style.display = 'none';
            }
        }

        function startGame() {
            if (gameMode === 'ai') {
                startAIGame();
            } else if (gameMode === 'puzzles') {
                startPuzzle();
            }
        }

        function startAIGame() {
            // Handle random color
            if (playerColor === 'random') {
                playerColor = Math.random() < 0.5 ? 'w' : 'b';
            }

            // Initialize chess.js
            game = new Chess();
            selectedSquare = null;
            capturedPieces = { w: [], b: [] };
            lastMove = null;
            gameOver = false;

            // Switch to game view
            setupScreen.style.display = 'none';
            gameLayout.classList.add('active');
            statusBar.style.display = 'flex';
            gameControls.style.display = 'flex';
            puzzleControls.style.display = 'none';

            // Clear move list
            moveListEl.innerHTML = '';
            moveErrorEl.textContent = '';
            moveTextEl.value = '';

            // Update captured pieces display
            document.getElementById('captured-white').textContent = '';
            document.getElementById('captured-black').textContent = '';

            // Create board and render
            createBoard();
            renderPosition();
            updateStatus();

            // Initialize Stockfish if not already done
            if (!stockfish) {
                initStockfish();
            } else if (stockfishReady) {
                setSkillLevel(skillLevel);
                // If player is black, AI moves first
                if (playerColor === 'b') {
                    setTimeout(makeAIMove, 500);
                }
            }
        }

        function startPuzzle() {
            currentPuzzle = MATING_PUZZLES[puzzleIndex % MATING_PUZZLES.length];
            puzzleMoveIndex = 0;
            puzzleSolved = false;
            gameOver = false;
            selectedSquare = null;
            lastMove = null;

            // Load puzzle position (before setup move)
            game = new Chess(currentPuzzle.fen);

            // Play the setup move (opponent's move that creates the puzzle)
            const setupMove = currentPuzzle.moves[0];
            const from = setupMove.substring(0, 2);
            const to = setupMove.substring(2, 4);
            const promotion = setupMove[4];
            const setupMoveObj = game.move({ from, to, promotion });
            if (setupMoveObj) {
                lastMove = setupMoveObj;
            }

            // Extract solution (remaining moves after setup)
            puzzleSolution = currentPuzzle.moves.slice(1);

            // Player plays as the side to move (after setup)
            playerColor = game.turn();

            // Switch to game view
            setupScreen.style.display = 'none';
            gameLayout.classList.add('active');
            statusBar.style.display = 'flex';
            gameControls.style.display = 'none';
            puzzleControls.style.display = 'flex';

            // Clear move list
            moveListEl.innerHTML = '';
            moveErrorEl.textContent = '';
            moveTextEl.value = '';

            // Update captured pieces display
            document.getElementById('captured-white').textContent = '';
            document.getElementById('captured-black').textContent = '';

            // Create board and render
            createBoard();
            renderPosition();

            const puzzleNum = (puzzleIndex % MATING_PUZZLES.length) + 1;
            showStatus(`Puzzle ${puzzleNum}/${MATING_PUZZLES.length} - Find the winning move!`);
        }

        function nextPuzzle() {
            puzzleIndex++;
            startPuzzle();
        }

        function retryPuzzle() {
            startPuzzle();
        }

        function showSolution() {
            if (!currentPuzzle) return;

            // Reset to puzzle start (load FEN, play setup move)
            game = new Chess(currentPuzzle.fen);

            // Play setup move first
            const setupMove = currentPuzzle.moves[0];
            const setupFrom = setupMove.substring(0, 2);
            const setupTo = setupMove.substring(2, 4);
            const setupPromotion = setupMove[4];
            const setupMoveObj = game.move({ from: setupFrom, to: setupTo, promotion: setupPromotion });
            if (setupMoveObj) {
                lastMove = setupMoveObj;
            }

            playerColor = game.turn();
            puzzleMoveIndex = 0;
            puzzleSolved = true;
            gameOver = true;

            // Play solution moves with animation
            let moveIdx = 0;
            const playNextMove = () => {
                if (moveIdx >= puzzleSolution.length) {
                    showStatus('Solution complete!');
                    gameStatusEl.classList.add('correct');
                    return;
                }

                const uciMove = puzzleSolution[moveIdx];
                const from = uciMove.substring(0, 2);
                const to = uciMove.substring(2, 4);
                const promotion = uciMove[4];

                const move = game.move({ from, to, promotion });
                if (move) {
                    lastMove = move;
                    renderPosition();
                    updateMoveList(move);
                }

                moveIdx++;
                setTimeout(playNextMove, 800);
            };

            createBoard();
            renderPosition();
            moveListEl.innerHTML = '';
            setTimeout(playNextMove, 500);
        }

        function handlePuzzleMove(move) {
            const expectedUci = puzzleSolution[puzzleMoveIndex];
            const playerUci = move.from + move.to + (move.promotion || '');

            if (playerUci === expectedUci) {
                // Correct move!
                puzzleMoveIndex++;
                lastMove = move;
                renderPosition();
                updateMoveList(move);

                // Check if puzzle is complete
                if (puzzleMoveIndex >= puzzleSolution.length) {
                    puzzleSolved = true;
                    gameOver = true;
                    showStatus('Correct! Puzzle solved!');
                    gameStatusEl.classList.remove('wrong');
                    gameStatusEl.classList.add('correct');
                    return;
                }

                // Make opponent's response after a short delay
                setTimeout(() => {
                    const responseUci = puzzleSolution[puzzleMoveIndex];
                    const from = responseUci.substring(0, 2);
                    const to = responseUci.substring(2, 4);
                    const promotion = responseUci[4];

                    const responseMove = game.move({ from, to, promotion });
                    if (responseMove) {
                        puzzleMoveIndex++;
                        lastMove = responseMove;
                        renderPosition();
                        updateMoveList(responseMove);

                        if (puzzleMoveIndex >= puzzleSolution.length) {
                            puzzleSolved = true;
                            gameOver = true;
                            showStatus('Correct! Puzzle solved!');
                            gameStatusEl.classList.add('correct');
                        } else {
                            showStatus('Correct! Keep going...');
                            gameStatusEl.classList.remove('wrong');
                            gameStatusEl.classList.add('correct');
                            setTimeout(() => {
                                gameStatusEl.classList.remove('correct');
                                showStatus('Find the next move!');
                            }, 1000);
                        }
                    }
                }, 400);
            } else {
                // Wrong move - undo it
                game.undo();
                showStatus('Not quite - try again!');
                gameStatusEl.classList.remove('correct');
                gameStatusEl.classList.add('wrong');
                setTimeout(() => {
                    gameStatusEl.classList.remove('wrong');
                    showStatus('Find the winning move!');
                }, 1500);
            }
        }

        function createBoard() {
            boardEl.innerHTML = '';

            // Determine board orientation
            const isFlipped = playerColor === 'b';
            const ranks = isFlipped ? [1,2,3,4,5,6,7,8] : [8,7,6,5,4,3,2,1];
            const files = isFlipped ? [7,6,5,4,3,2,1,0] : [0,1,2,3,4,5,6,7];

            // Update labels for board orientation
            const fileLabels = isFlipped ? 'hgfedcba' : 'abcdefgh';
            const rankLabels = isFlipped ? '12345678' : '87654321';

            document.querySelectorAll('.file-labels').forEach(el => {
                el.innerHTML = fileLabels.split('').map(f => `<span>${f}</span>`).join('');
            });
            document.getElementById('rank-labels').innerHTML =
                rankLabels.split('').map(r => `<span>${r}</span>`).join('');

            for (let rankIdx = 0; rankIdx < 8; rankIdx++) {
                for (let fileIdx = 0; fileIdx < 8; fileIdx++) {
                    const rank = ranks[rankIdx];
                    const file = files[fileIdx];
                    const squareName = String.fromCharCode(97 + file) + rank;
                    const isLight = (rank + file) % 2 === 1;

                    const square = document.createElement('div');
                    square.className = `square ${isLight ? 'light' : 'dark'}`;
                    square.dataset.square = squareName;
                    square.onclick = () => handleSquareClick(squareName);

                    boardEl.appendChild(square);
                }
            }
        }

        function renderPosition() {
            const position = game.board();

            document.querySelectorAll('.square').forEach(squareEl => {
                const squareName = squareEl.dataset.square;
                const file = squareName.charCodeAt(0) - 97;
                const rank = parseInt(squareName[1]) - 1;

                const piece = position[7 - rank][file];

                // Clear previous content
                squareEl.textContent = '';
                squareEl.classList.remove('white-piece', 'black-piece', 'piece-p', 'piece-b', 'piece-n', 'piece-r', 'piece-q', 'piece-k');

                if (piece) {
                    const symbol = piece.color === 'w'
                        ? PIECES[piece.type.toUpperCase()]
                        : PIECES[piece.type];
                    squareEl.textContent = symbol;
                    squareEl.classList.add(piece.color === 'w' ? 'white-piece' : 'black-piece');
                    squareEl.classList.add('piece-' + piece.type);
                }
            });

            // Highlight last move
            highlightLastMove();

            // Highlight check
            highlightCheck();
        }

        function highlightLastMove() {
            document.querySelectorAll('.last-move-from, .last-move-to').forEach(el => {
                el.classList.remove('last-move-from', 'last-move-to');
            });

            if (lastMove) {
                const fromEl = document.querySelector(`[data-square="${lastMove.from}"]`);
                const toEl = document.querySelector(`[data-square="${lastMove.to}"]`);
                if (fromEl) fromEl.classList.add('last-move-from');
                if (toEl) toEl.classList.add('last-move-to');
            }
        }

        function highlightCheck() {
            document.querySelectorAll('.check').forEach(el => el.classList.remove('check'));

            if (game.in_check()) {
                // Find the king that's in check
                const turn = game.turn();
                const position = game.board();

                for (let rank = 0; rank < 8; rank++) {
                    for (let file = 0; file < 8; file++) {
                        const piece = position[rank][file];
                        if (piece && piece.type === 'k' && piece.color === turn) {
                            const squareName = String.fromCharCode(97 + file) + (8 - rank);
                            const squareEl = document.querySelector(`[data-square="${squareName}"]`);
                            if (squareEl) squareEl.classList.add('check');
                            return;
                        }
                    }
                }
            }
        }

        function handleSquareClick(square) {
            if (gameOver || !isPlayerTurn()) return;

            const piece = game.get(square);

            if (selectedSquare) {
                // Second click - try to move
                const move = tryMove(selectedSquare, square);
                if (move) {
                    clearHighlights();
                    afterPlayerMove(move);
                } else if (piece && piece.color === playerColor) {
                    // Clicked own piece - select it instead
                    selectSquare(square);
                } else {
                    // Invalid move
                    clearHighlights();
                    selectedSquare = null;
                }
            } else {
                // First click - select piece
                if (piece && piece.color === playerColor) {
                    selectSquare(square);
                }
            }
        }

        function selectSquare(square) {
            clearHighlights();
            selectedSquare = square;

            const squareEl = document.querySelector(`[data-square="${square}"]`);
            squareEl.classList.add('selected');
        }

        function clearHighlights() {
            document.querySelectorAll('.selected, .legal-move, .legal-capture').forEach(el => {
                el.classList.remove('selected', 'legal-move', 'legal-capture');
            });
            selectedSquare = null;
        }

        function tryMove(from, to) {
            // Check for pawn promotion
            const piece = game.get(from);
            const isPromotion = piece && piece.type === 'p' &&
                ((piece.color === 'w' && to[1] === '8') ||
                 (piece.color === 'b' && to[1] === '1'));

            const moveObj = {
                from: from,
                to: to,
                promotion: isPromotion ? 'q' : undefined  // Auto-queen
            };

            return game.move(moveObj);
        }

        function submitTextMove() {
            if (gameOver || !isPlayerTurn()) return;

            const moveText = moveTextEl.value.trim();
            if (!moveText) return;

            // chess.js accepts SAN notation
            const move = game.move(moveText);

            if (move) {
                moveErrorEl.textContent = '';
                moveTextEl.value = '';
                clearHighlights();
                afterPlayerMove(move);
            } else {
                moveErrorEl.textContent = `Invalid: "${moveText}"`;
            }
        }

        function afterPlayerMove(move) {
            if (gameMode !== 'ai') {
                // Puzzle mode - check if move is correct
                handlePuzzleMove(move);
                return;
            }

            lastMove = move;
            updateCaptured(move);
            renderPosition();
            updateMoveList(move);
            updateStatus();

            if (game.game_over()) {
                handleGameOver();
            } else {
                // AI's turn
                setTimeout(makeAIMove, 300);
            }
        }

        function isPlayerTurn() {
            return game.turn() === playerColor;
        }

        function updateStatus() {
            gameStatusEl.classList.remove('thinking', 'check', 'game-over');

            if (gameOver) {
                return;
            }

            if (game.in_check()) {
                gameStatusEl.textContent = isPlayerTurn() ? 'Check! Your turn' : 'Check!';
                gameStatusEl.classList.add('check');
            } else if (isPlayerTurn()) {
                gameStatusEl.textContent = 'Your turn';
            } else {
                gameStatusEl.textContent = 'Thinking...';
                gameStatusEl.classList.add('thinking');
            }
        }

        function updateCaptured(move) {
            if (move.captured) {
                const capturedColor = move.color === 'w' ? 'b' : 'w';
                capturedPieces[capturedColor].push(move.captured);
                renderCaptured();
            }
        }

        function renderCaptured() {
            const order = ['q', 'r', 'b', 'n', 'p'];

            const whiteCaptured = [...capturedPieces.w].sort((a, b) => order.indexOf(a) - order.indexOf(b));
            const blackCaptured = [...capturedPieces.b].sort((a, b) => order.indexOf(a) - order.indexOf(b));

            document.getElementById('captured-white').textContent =
                whiteCaptured.map(p => PIECES[p.toUpperCase()]).join('');
            document.getElementById('captured-black').textContent =
                blackCaptured.map(p => PIECES[p]).join('');
        }

        function updateMoveList(move) {
            const history = game.history();
            const moveNum = Math.ceil(history.length / 2);
            const isWhiteMove = history.length % 2 === 1;

            if (isWhiteMove) {
                const row = document.createElement('div');
                row.className = 'move-row';
                row.innerHTML = `
                    <span class="move-num">${moveNum}.</span>
                    <span class="white-move">${move.san}</span>
                    <span class="black-move"></span>
                `;
                moveListEl.appendChild(row);
            } else {
                const lastRow = moveListEl.lastElementChild;
                if (lastRow) {
                    lastRow.querySelector('.black-move').textContent = move.san;
                }
            }

            moveListEl.scrollTop = moveListEl.scrollHeight;
        }

        function rebuildMoveList() {
            moveListEl.innerHTML = '';
            const history = game.history();

            for (let i = 0; i < history.length; i += 2) {
                const moveNum = Math.floor(i / 2) + 1;
                const row = document.createElement('div');
                row.className = 'move-row';
                row.innerHTML = `
                    <span class="move-num">${moveNum}.</span>
                    <span class="white-move">${history[i]}</span>
                    <span class="black-move">${history[i + 1] || ''}</span>
                `;
                moveListEl.appendChild(row);
            }
        }

        function undoMove() {
            if (gameOver || game.history().length < 2) return;

            // Undo AI move and player move
            const undone1 = game.undo();
            const undone2 = game.undo();

            // Restore captured pieces
            if (undone1 && undone1.captured) {
                const color = undone1.color === 'w' ? 'b' : 'w';
                const idx = capturedPieces[color].lastIndexOf(undone1.captured);
                if (idx > -1) capturedPieces[color].splice(idx, 1);
            }
            if (undone2 && undone2.captured) {
                const color = undone2.color === 'w' ? 'b' : 'w';
                const idx = capturedPieces[color].lastIndexOf(undone2.captured);
                if (idx > -1) capturedPieces[color].splice(idx, 1);
            }

            // Update last move
            const history = game.history({ verbose: true });
            lastMove = history.length > 0 ? history[history.length - 1] : null;

            renderCaptured();
            renderPosition();
            rebuildMoveList();
            updateStatus();
        }

        function resignGame() {
            if (gameOver) return;
            if (confirm('Are you sure you want to resign?')) {
                gameOver = true;
                showGameOver('You resigned');
            }
        }

        function handleGameOver() {
            gameOver = true;
            let message = '';

            if (game.in_checkmate()) {
                const winner = game.turn() === 'w' ? 'Black' : 'White';
                const playerWon = (winner === 'White' && playerColor === 'w') ||
                                 (winner === 'Black' && playerColor === 'b');
                message = playerWon ? 'Checkmate! You win!' : 'Checkmate! You lose!';
            } else if (game.in_stalemate()) {
                message = 'Stalemate! Draw.';
            } else if (game.in_threefold_repetition()) {
                message = 'Threefold repetition! Draw.';
            } else if (game.insufficient_material()) {
                message = 'Insufficient material! Draw.';
            } else if (game.in_draw()) {
                message = 'Draw!';
            }

            showGameOver(message);
        }

        function showGameOver(message) {
            gameStatusEl.textContent = message;
            gameStatusEl.classList.add('game-over');
            gameOverMessage.textContent = message;
            gameOverModal.classList.add('active');
        }

        // ============ STOCKFISH ============

        function initStockfish() {
            showStatus('Loading engine...');

            // Try to load Stockfish
            try {
                stockfish = new Worker('js/stockfish.min.js');

                stockfish.onmessage = (event) => {
                    const line = event.data;

                    if (line === 'uciok') {
                        stockfish.postMessage('isready');
                    } else if (line === 'readyok') {
                        stockfishReady = true;
                        setSkillLevel(skillLevel);
                        updateStatus();

                        // If player is black, AI moves first
                        if (playerColor === 'b' && !gameOver) {
                            setTimeout(makeAIMove, 500);
                        }
                    } else if (line.startsWith('bestmove')) {
                        handleStockfishMove(line);
                    }
                };

                stockfish.onerror = (err) => {
                    console.error('Stockfish error:', err);
                    stockfishReady = false;
                    showStatus('Engine error - reload page');
                };

                stockfish.postMessage('uci');
            } catch (err) {
                console.error('Failed to load Stockfish:', err);
                showStatus('Engine not available');
            }
        }

        function setSkillLevel(level) {
            if (stockfish && stockfishReady) {
                stockfish.postMessage('setoption name Skill Level value ' + level);
            }
        }

        function showStatus(msg) {
            gameStatusEl.textContent = msg;
        }

        function makeAIMove() {
            if (gameOver || !stockfishReady || isPlayerTurn()) return;

            updateStatus();

            const fen = game.fen();
            stockfish.postMessage('position fen ' + fen);

            // Think time based on difficulty
            const thinkTime = getThinkTime(skillLevel);
            stockfish.postMessage(`go movetime ${thinkTime}`);
        }

        function getThinkTime(level) {
            // Use the stored thinkTime from difficulty selection
            return thinkTime;
        }

        function handleStockfishMove(line) {
            const parts = line.split(' ');
            const moveStr = parts[1];

            if (!moveStr || moveStr === '(none)') {
                handleGameOver();
                return;
            }

            // Parse Stockfish format (e2e4, e7e8q for promotion)
            const from = moveStr.substring(0, 2);
            const to = moveStr.substring(2, 4);
            const promotion = moveStr[4];

            const move = game.move({
                from: from,
                to: to,
                promotion: promotion || undefined
            });

            if (move) {
                lastMove = move;
                updateCaptured(move);
                renderPosition();
                updateMoveList(move);

                if (game.game_over()) {
                    handleGameOver();
                } else {
                    updateStatus();
                }
            }
        }
    </script>
    <script type="module" src="js/analytics.js"></script>
</body>
</html>
