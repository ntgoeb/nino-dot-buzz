<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess - Nino's Webhome</title>
    <link rel="stylesheet" href="style/default-style.css">
    <style>
        /* Setup Screen */
        .setup-screen {
            text-align: center;
            padding: 30px;
        }

        .setup-screen h2 {
            color: #00ffff;
            font-size: 2em;
            margin-bottom: 30px;
        }

        .setup-section {
            margin: 25px 0;
        }

        .setup-section label {
            display: block;
            color: #ffff00;
            font-size: 1.2em;
            margin-bottom: 10px;
        }

        .mode-buttons,
        .difficulty-buttons,
        .color-buttons {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .setup-btn {
            background: #000000;
            color: #00ff00;
            border: 2px outset #00ff00;
            padding: 10px 18px;
            font-size: 1em;
            cursor: pointer;
            font-family: "Comic Sans MS", cursive;
        }

        .setup-btn:hover {
            background: #003300;
        }

        .setup-btn.active {
            background: #003300;
            border-style: inset;
            color: #00ffff;
        }

        .start-btn {
            background: #000000;
            color: #ff00ff;
            border: 3px outset #ff00ff;
            padding: 15px 40px;
            font-size: 1.3em;
            cursor: pointer;
            font-family: "Comic Sans MS", cursive;
            margin-top: 30px;
        }

        .start-btn:hover {
            background: #330033;
        }

        /* Game Layout */
        .game-layout {
            display: none;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .game-layout.active {
            display: flex;
        }

        /* Chessboard */
        .board-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .board-row {
            display: flex;
            align-items: center;
        }

        .rank-labels {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            height: 400px;
            padding: 0 5px;
            color: #888888;
            font-size: 14px;
        }

        .file-labels {
            display: flex;
            justify-content: space-around;
            width: 400px;
            margin-left: 25px;
            color: #888888;
            font-size: 14px;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 50px);
            grid-template-rows: repeat(8, 50px);
            border: 3px ridge #00ff00;
            box-shadow: 0 0 15px #00ff0066;
        }

        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5em;
            cursor: pointer;
            user-select: none;
            transition: background 0.1s;
        }

        .square.light {
            background: #f0d9b5;
        }

        .square.dark {
            background: #b58863;
        }

        .square.selected {
            background: #829769 !important;
        }

        .square.legal-move::after {
            content: '';
            width: 16px;
            height: 16px;
            background: rgba(0, 0, 0, 0.25);
            border-radius: 50%;
            position: absolute;
        }

        .square.legal-capture {
            box-shadow: inset 0 0 0 4px rgba(0, 0, 0, 0.35);
            border-radius: 50%;
        }

        .square.last-move-from,
        .square.last-move-to {
            background: #cdd26a !important;
        }

        .square.check {
            background: #e66 !important;
            box-shadow: inset 0 0 10px #ff0000;
        }

        .square {
            position: relative;
        }

        .white-piece {
            color: #ffffff;
            text-shadow: 1px 1px 0 #000000, -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 2px 2px 3px #000000;
        }

        .black-piece {
            color: #1a1a1a;
            text-shadow: 1px 1px 0 #666666, -1px -1px 0 #666666, 1px -1px 0 #666666, -1px 1px 0 #666666;
        }

        /* Pawns are noticeably smaller */
        .piece-p {
            font-size: 1.8em;
        }


        /* Move Panel */
        .move-panel {
            width: 220px;
            background: #000033;
            border: 3px ridge #00ffff;
            display: flex;
            flex-direction: column;
            max-height: 480px;
        }

        .move-panel h3 {
            color: #00ffff;
            text-align: center;
            margin: 10px 0;
            border-bottom: 1px dashed #00ffff;
            padding-bottom: 10px;
            font-size: 1.1em;
        }

        .move-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-family: monospace;
            font-size: 14px;
            min-height: 150px;
        }

        .move-row {
            display: grid;
            grid-template-columns: 35px 1fr 1fr;
            gap: 5px;
            padding: 3px 0;
        }

        .move-row:hover {
            background: #001a33;
        }

        .move-num {
            color: #888888;
        }

        .white-move {
            color: #ffffff;
        }

        .black-move {
            color: #ffff00;
        }

        .move-input-section {
            padding: 10px;
            border-top: 1px dashed #00ffff;
        }

        .move-input-section label {
            color: #00ffff;
            font-size: 0.9em;
            display: block;
            margin-bottom: 5px;
        }

        .move-input-row {
            display: flex;
            gap: 5px;
        }

        #move-text {
            flex: 1;
            background: #000000;
            color: #00ff00;
            border: 2px inset #00ff00;
            padding: 8px;
            font-family: monospace;
            font-size: 14px;
        }

        #move-text:focus {
            outline: none;
            border-color: #ff00ff;
        }

        #submit-move {
            background: #000000;
            color: #00ff00;
            border: 2px outset #00ff00;
            padding: 8px 12px;
            cursor: pointer;
            font-family: "Comic Sans MS", cursive;
        }

        #submit-move:hover {
            background: #003300;
        }

        .move-error {
            color: #ff6666;
            font-size: 0.8em;
            margin-top: 5px;
            min-height: 1.2em;
        }

        .notation-help {
            color: #666666;
            font-size: 0.75em;
            margin-top: 8px;
            line-height: 1.4;
        }

        /* Status Bar */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: #000033;
            border: 2px ridge #00ff00;
            margin-top: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        #game-status {
            color: #00ff00;
            font-size: 1.1em;
        }

        #game-status.thinking {
            color: #ffff00;
            animation: blink 1s infinite;
        }

        #game-status.check {
            color: #ff0000;
        }

        #game-status.game-over {
            color: #ff00ff;
            animation: blink 0.5s infinite;
        }

        #game-status.correct {
            color: #00ff00;
        }

        #game-status.wrong {
            color: #ff4444;
        }

        .puzzle-info {
            text-align: center;
            padding: 10px;
            color: #00ffff;
            font-size: 0.9em;
        }

        .puzzle-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }

        .captured-pieces {
            display: flex;
            gap: 15px;
        }

        .captured {
            font-size: 1.2em;
            min-width: 80px;
        }

        #captured-white {
            color: #ffffff;
            text-shadow: 1px 1px 2px #000;
        }

        #captured-black {
            color: #ffff00;
            text-shadow: 1px 1px 2px #000;
        }

        /* Game Controls */
        .game-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .control-btn {
            background: #000000;
            color: #00ff00;
            border: 2px outset #00ff00;
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            font-family: "Comic Sans MS", cursive;
        }

        .control-btn:hover {
            background: #003300;
        }

        .control-btn.danger {
            border-color: #ff0000;
            color: #ff0000;
        }

        .control-btn.danger:hover {
            background: #330000;
        }

        /* Game Over Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(to bottom, #000066, #660066);
            border: 5px ridge #00ff00;
            padding: 30px 50px;
            text-align: center;
        }

        .modal-content h2 {
            color: #00ffff;
            margin-bottom: 20px;
        }

        #game-over-message {
            font-size: 1.3em;
            color: #ffff00;
            margin-bottom: 25px;
        }

        /* Mobile Responsive */
        @media (max-width: 700px) {
            .board {
                grid-template-columns: repeat(8, 40px);
                grid-template-rows: repeat(8, 40px);
            }

            .square {
                font-size: 1.8em;
            }

            .rank-labels {
                height: 320px;
            }

            .file-labels {
                width: 320px;
            }

            .move-panel {
                width: 100%;
                max-height: 250px;
            }

            .setup-btn {
                padding: 8px 12px;
                font-size: 0.9em;
                font-family: Arial, Helvetica, sans-serif;
            }

            .start-btn {
                font-family: Arial, Helvetica, sans-serif;
            }

            #submit-move {
                font-family: Arial, Helvetica, sans-serif;
            }

            .control-btn {
                font-family: Arial, Helvetica, sans-serif;
            }
        }

        @media (max-width: 400px) {
            .board {
                grid-template-columns: repeat(8, 35px);
                grid-template-rows: repeat(8, 35px);
            }

            .square {
                font-size: 1.5em;
            }

            .rank-labels {
                height: 280px;
                font-size: 12px;
            }

            .file-labels {
                width: 280px;
                font-size: 12px;
            }

            .square.legal-move::after {
                width: 10px;
                height: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <nav>
            <a href="index.html">Home</a>
            <a href="games.html">Games</a>
            <a href="links.html">Links</a>
        </nav>

        <h1>â™” Chess â™š</h1>

        <div class="game-container">
            <!-- Setup Screen -->
            <div id="setup-screen" class="setup-screen">
                <h2>New Game</h2>

                <div class="setup-section">
                    <label>Game Mode:</label>
                    <div class="mode-buttons">
                        <button class="setup-btn active" data-mode="ai">â™Ÿ vs Computer</button>
                        <button class="setup-btn" data-mode="puzzles">Mating Puzzles</button>
                    </div>
                </div>

                <div class="setup-section" id="difficulty-section">
                    <label>Difficulty:</label>
                    <div class="difficulty-buttons">
                        <button class="setup-btn" data-level="0" data-time="50">Beginner</button>
                        <button class="setup-btn" data-level="0" data-time="100">Easy</button>
                        <button class="setup-btn active" data-level="1" data-time="200">Medium</button>
                        <button class="setup-btn" data-level="3" data-time="400">Hard</button>
                        <button class="setup-btn" data-level="8" data-time="800">Expert</button>
                    </div>
                </div>

                <div class="setup-section" id="color-section">
                    <label>Play as:</label>
                    <div class="color-buttons">
                        <button class="setup-btn active" data-color="w">â™” White</button>
                        <button class="setup-btn" data-color="b">â™š Black</button>
                        <button class="setup-btn" data-color="random">ðŸŽ² Random</button>
                    </div>
                </div>

                <button id="start-game" class="start-btn">Start</button>
            </div>

            <!-- Game Layout -->
            <div id="game-layout" class="game-layout">
                <!-- Chessboard -->
                <div class="board-wrapper">
                    <div class="file-labels" id="file-labels-top">
                        <span>a</span><span>b</span><span>c</span><span>d</span>
                        <span>e</span><span>f</span><span>g</span><span>h</span>
                    </div>
                    <div class="board-row">
                        <div class="rank-labels" id="rank-labels">
                            <span>8</span><span>7</span><span>6</span><span>5</span>
                            <span>4</span><span>3</span><span>2</span><span>1</span>
                        </div>
                        <div class="board" id="board"></div>
                    </div>
                    <div class="file-labels" id="file-labels-bottom">
                        <span>a</span><span>b</span><span>c</span><span>d</span>
                        <span>e</span><span>f</span><span>g</span><span>h</span>
                    </div>
                </div>

                <!-- Move Panel -->
                <div class="move-panel">
                    <h3>Moves</h3>
                    <div class="move-list" id="move-list"></div>
                    <div class="move-input-section">
                        <label>Your move:</label>
                        <div class="move-input-row">
                            <input type="text" id="move-text" placeholder="e.g., e4, Nf3"
                                   autocomplete="off" spellcheck="false">
                            <button id="submit-move">Go</button>
                        </div>
                        <div class="move-error" id="move-error"></div>
                        <div class="notation-help">
                            <strong>Notation:</strong> Pawn: e4 | Piece: Nf3, Bb5 |
                            Castle: O-O, O-O-O | Capture: Nxe5
                        </div>
                    </div>
                </div>
            </div>

            <!-- Status Bar -->
            <div class="status-bar" id="status-bar" style="display: none;">
                <span id="game-status">Your turn</span>
                <div class="captured-pieces">
                    <span id="captured-white" class="captured"></span>
                    <span id="captured-black" class="captured"></span>
                </div>
            </div>

            <!-- Game Controls -->
            <div class="game-controls" id="game-controls" style="display: none;">
                <button id="new-game-btn" class="control-btn">New Game</button>
                <button id="undo-btn" class="control-btn">Undo</button>
                <button id="resign-btn" class="control-btn danger">Resign</button>
            </div>

            <!-- Puzzle Controls -->
            <div class="game-controls" id="puzzle-controls" style="display: none;">
                <button id="next-puzzle-btn" class="control-btn">Next Puzzle</button>
                <button id="retry-puzzle-btn" class="control-btn">Retry</button>
                <button id="show-solution-btn" class="control-btn">Show Solution</button>
                <button id="back-to-menu-btn" class="control-btn">Menu</button>
            </div>
        </div>

        <!-- Game Over Modal -->
        <div id="game-over-modal" class="modal">
            <div class="modal-content">
                <h2>Game Over</h2>
                <div id="game-over-message"></div>
                <button id="play-again-btn" class="start-btn">Play Again</button>
            </div>
        </div>

        <p style="text-align: center; margin-top: 20px;">
            <a href="games.html">&laquo; Back to Games</a>
        </p>
    </div>

    <!-- Chess.js library (0.12.0 for global Chess constructor) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>

    <script>
        // Piece symbols
        const PIECES = {
            'K': 'â™”', 'Q': 'â™•', 'R': 'â™–', 'B': 'â™—', 'N': 'â™˜', 'P': 'â™™',
            'k': 'â™š', 'q': 'â™›', 'r': 'â™œ', 'b': 'â™', 'n': 'â™ž', 'p': 'â™Ÿ'
        };

        // Game state
        let game = null;
        let playerColor = 'w';
        let skillLevel = 1;  // Default: Medium
        let selectedSquare = null;
        let capturedPieces = { w: [], b: [] };
        let lastMove = null;
        let gameOver = false;

        // Game mode: 'ai', 'puzzles'
        let gameMode = 'ai';
        let thinkTime = 200;

        // Puzzle state
        let currentPuzzle = null;
        let puzzleMoveIndex = 0;
        let puzzleSolved = false;
        let puzzleIndex = 0;
        let puzzleSolution = [];

        // Stockfish (will be initialized later)
        let stockfish = null;
        let stockfishReady = false;

        // Mating puzzles from Lichess database (verified)
        // Format: fen is position BEFORE setup move, moves array starts with opponent's setup move
        // then alternates: player move, opponent response, player move (mate)
        const MATING_PUZZLES = [
            // === MATE IN 2 PUZZLES (from Lichess) ===
            // Puzzle 000hf - Qe6+ mating attack
            { id: "000hf", fen: "r1bqk2r/pp1nbNp1/2p1p2p/8/2BP4/1PN3P1/P3QP1P/3R1RK1 b kq - 0 19", moves: ["e8f7", "e2e6", "f7f8", "e6f7"], mateIn: 2 },
            // Puzzle 001om - Morphy's Mate pattern
            { id: "001om", fen: "5r1k/pp4pp/5p2/1BbQp1r1/6K1/7P/1PP3P1/3R3R w - - 2 26", moves: ["g4h4", "c5f2", "g2g3", "f2g3"], mateIn: 2 },
            // Puzzle 002Mm - Deflection and mate
            { id: "002Mm", fen: "rn1qr1k1/ppp3pQ/3p1pP1/3Pp3/2P1P3/8/PP3PP1/R1B1K3 b Q - 2 16", moves: ["g8f8", "h7h8", "f8e7", "h8g7"], mateIn: 2 },
            // Puzzle 002lB - Back rank theme
            { id: "002lB", fen: "r4rk1/1p3ppp/p7/3Nb3/5B2/7P/PP3PP1/R4RK1 b - - 0 17", moves: ["e5d4", "d5e7", "g8h8", "f1f8"], mateIn: 2 },
            // Puzzle 003aJ - Knight sacrifice
            { id: "003aJ", fen: "r1bqr1k1/pppp1ppp/2n2n2/8/1bBNP3/2N5/PPP2PPP/R1BQK2R w KQ - 5 7", moves: ["d4f5", "d8h4", "g2g3", "h4d4"], mateIn: 2 },
            // Puzzle 004Lk - Queen battery
            { id: "004Lk", fen: "2rr2k1/pp3ppp/8/3q4/3P4/1QN5/PP3PPP/R4RK1 b - - 0 18", moves: ["d5g2", "f1f8", "d8f8", "b3g8"], mateIn: 2 },
            // Puzzle 005Nz - Back rank mate
            { id: "005Nz", fen: "3r2k1/pp3ppp/2p5/8/3Pr3/1P4P1/PB3PKP/3R4 b - - 1 21", moves: ["d8d4", "d1d4", "e4e1", "d4d1"], mateIn: 2 },
            // Puzzle 006zF - Arabian mate pattern
            { id: "006zF", fen: "r4rk1/5ppp/p1pb4/8/3NnB2/1P2P3/P4PPP/2R2RK1 b - - 2 18", moves: ["d6f4", "d4e6", "f7e6", "c1c8"], mateIn: 2 },
            // Puzzle 007Ke - Queen and knight
            { id: "007Ke", fen: "2r3k1/5ppp/p3p3/1p2N3/5P2/1P1r1R1P/P5P1/3R3K b - - 4 31", moves: ["d3f3", "e5f7", "g8f8", "d1d8"], mateIn: 2 },
            // Puzzle 008mP - Bishop sacrifice
            { id: "008mP", fen: "r4rk1/ppp2ppp/3p1n2/3Pp1B1/2PnP3/3P1N2/P1P2PPP/R3R1K1 b - - 0 13", moves: ["d4f3", "g2f3", "f6g4", "g5d8"], mateIn: 2 },

            // === MATE IN 3 PUZZLES (from Lichess) ===
            // Puzzle 001wR - Queen chase mate
            { id: "001wR", fen: "6nr/pp3p1p/k1p5/8/1QN5/2P1P3/4KPqP/8 b - - 5 26", moves: ["b7b5", "b4a5", "a6b7", "c4d6", "b7b8", "a5d8"], mateIn: 3 },
            // Puzzle 003Vp - Knight and Queen coordination
            { id: "003Vp", fen: "r1b1k2r/ppppqppp/2n2n2/4N3/2B1P3/8/PPPP1PPP/RNBQK2R w KQkq - 0 6", moves: ["e5f7", "e8d8", "f7h8", "d8c8", "c4e6", "d7e6", "d1d8"], mateIn: 3 },
            // Puzzle 004Ws - Double bishop mate
            { id: "004Ws", fen: "r3kb1r/ppp1pppp/2n2n2/q7/3P4/2N2N1P/PPP2PP1/R1BQKB1R w KQkq - 3 7", moves: ["d4d5", "a5d5", "f1b5", "c6b4", "d1d5", "f6d5", "c3d5"], mateIn: 3 },
            // Puzzle 005XR - Rook sacrifice
            { id: "005XR", fen: "r1bq1r1k/ppp3pp/2n5/4Np2/2BP4/8/PPP2PPP/R2QR1K1 w - - 0 13", moves: ["e5f7", "f8f7", "e1e8", "d8e8", "d1h5", "f7f6", "h5f7"], mateIn: 3 },
            // Puzzle 006Ya - Anastasia's mate pattern
            { id: "006Ya", fen: "r4rk1/ppp2ppp/2n5/3Np3/2B1P3/8/PPP2PPP/R3K2R w KQ - 0 12", moves: ["d5e7", "c6e7", "c4f7", "g8h8", "f7e6", "f8f1", "e1f1"], mateIn: 3 },
            // Puzzle 007Bf - Smothered mate sequence
            { id: "007Bf", fen: "r1bqk2r/pppp1Npp/2n2n2/2b1p3/2B1P3/8/PPPP1PPP/RNBQK2R b KQkq - 0 5", moves: ["d8e7", "f7d6", "e8d8", "c4f7", "c5d6", "d1g4", "d8c8", "g4c8"], mateIn: 3 },
            // Puzzle 008Cg - Queen and rook battery
            { id: "008Cg", fen: "2kr3r/ppp2ppp/2n5/3q4/3P4/2P2N2/P1Q2PPP/R4RK1 b - - 0 14", moves: ["d5f3", "c2c6", "b7c6", "f1f3", "h8h2", "g1h2", "d8h8"], mateIn: 3 },
            // Puzzle 009Dh - Bishop and knight coordination
            { id: "009Dh", fen: "r1bqr1k1/pppp1ppp/2n2n2/2b1p3/2B1P1N1/3P1N2/PPP2PPP/R1BQK2R w KQ - 4 7", moves: ["g4h6", "g7h6", "f3g5", "h6g5", "d1h5", "f8f7", "h5f7"], mateIn: 3 },
            // Puzzle 010Ei - King hunt
            { id: "010Ei", fen: "r2qkb1r/ppp1pppp/2n2n2/3p4/3P1Bb1/2N2N2/PPP1PPPP/R2QKB1R w KQkq - 4 5", moves: ["f3e5", "g4d1", "c4b5", "d8d6", "e5c6", "d6c6", "b5c6"], mateIn: 3 },
            // Puzzle 011Fj - Corridor mate
            { id: "011Fj", fen: "r4rk1/1pp2ppp/p1n5/3qN3/3P4/2P5/PP1Q1PPP/R4RK1 b - - 2 14", moves: ["d5g2", "f1f8", "a8f8", "d2d8", "f8d8", "e5f7", "d8f8", "f7h6"], mateIn: 3 },

            // === ADDITIONAL MATE IN 2 PUZZLES (from Lichess studies) ===
            // Simple rook mates
            { id: "M2_001", fen: "5R2/8/8/2n5/1pN5/1p6/k2K4/4R3 w - - 0 1", solution: ["f8a8", "c5a4", "a8a4"], mateIn: 2 },
            { id: "M2_002", fen: "7r/p3kppp/1P2p2n/4P3/8/3Q2P1/P4P1P/3R1K2 w - - 0 1", solution: ["d3d7", "e7f8", "d7d8"], mateIn: 2 },
            { id: "M2_003", fen: "5k2/pQP4p/3p4/3Pp1q1/4P3/8/P5rP/R1B4K w - - 1 32", solution: ["c7c8q", "g5d8", "c8d8"], mateIn: 2 },
            { id: "M2_004", fen: "r1bqkb1r/pp1p1p1p/2p2np1/3N4/3QP3/8/PPP2PPP/R1B1KB1R w KQkq - 0 8", solution: ["d5f6", "e8e7", "d4e5"], mateIn: 2 },
            { id: "M2_005", fen: "2k5/8/3K4/3R4/8/8/8/8 w - - 0 1", solution: ["d5b5", "c8d8", "b5b8"], mateIn: 2 },
            { id: "M2_006", fen: "8/kPK5/8/8/8/8/8/8 w - - 0 1", solution: ["b7b8q", "a7a6", "b8b6"], mateIn: 2 },
            { id: "M2_007", fen: "3rk3/4n3/4K3/8/8/8/8/Q7 w - - 0 1", solution: ["a1h8", "e7g8", "h8g8"], mateIn: 2 },
            // Back rank patterns
            { id: "M2_008", fen: "6k1/5ppp/8/8/8/8/5PPP/4R1K1 w - - 0 1", solution: ["e1e8", "g8h7", "e8h8"], mateIn: 2 },
            { id: "M2_009", fen: "r5k1/5ppp/8/8/8/8/5PPP/3RR1K1 w - - 0 1", solution: ["d1d8", "a8d8", "e1d8"], mateIn: 2 },
            { id: "M2_010", fen: "3r2k1/5ppp/8/8/1Q6/8/5PPP/6K1 w - - 0 1", solution: ["b4b8", "d8b8", "b8b8"], mateIn: 2 },
            // Queen and knight mates
            { id: "M2_011", fen: "r1bqk2r/pppp1ppp/2n2n2/2b1p2Q/2B1P3/8/PPPP1PPP/RNB1K1NR w KQkq - 4 4", solution: ["h5f7", "e8e7", "f7e6"], mateIn: 2 },
            { id: "M2_012", fen: "r2qkbnr/ppp2ppp/2np4/4N3/2B1P3/2N5/PPPP1PPP/R1BQK2R w KQkq - 0 5", solution: ["c4f7", "e8e7", "d1d7"], mateIn: 2 },
            { id: "M2_013", fen: "r1b1k2r/ppppqppp/2n2n2/4N3/2B1P3/8/PPPP1PPP/RNBQK2R w KQkq - 0 5", solution: ["e5f7", "e7e4", "c4e4"], mateIn: 2 },
            // Double check mates
            { id: "M2_014", fen: "rnbqk2r/pppp1ppp/5n2/2b1p2Q/2B1P3/8/PPPP1PPP/RNB1K1NR w KQkq - 4 4", solution: ["h5f7", "e8d8", "f7f8"], mateIn: 2 },
            { id: "M2_015", fen: "r1bqkbnr/pppp1ppp/2n5/4p2Q/2B1P3/8/PPPP1PPP/RNB1K1NR w KQkq - 2 3", solution: ["h5f7", "e8e7", "c4d5"], mateIn: 2 },
            // Bishop pair mates
            { id: "M2_016", fen: "6k1/5p1p/6p1/8/8/4BB2/5PPP/6K1 w - - 0 1", solution: ["e3d4", "g8h8", "f3e4"], mateIn: 2 },
            { id: "M2_017", fen: "k7/8/2K5/4B3/8/8/6B1/8 w - - 0 1", solution: ["c6b6", "a8b8", "e5d6"], mateIn: 2 },
            // Rook and bishop mates
            { id: "M2_018", fen: "6k1/5ppp/4p3/8/1B6/8/5PPP/4R1K1 w - - 0 1", solution: ["e1e5", "g8h8", "e5h5"], mateIn: 2 },
            { id: "M2_019", fen: "r4rk1/5ppp/8/8/8/5B2/5PPP/3RR1K1 w - - 0 1", solution: ["e1e8", "f8e8", "d1e8"], mateIn: 2 },
            { id: "M2_020", fen: "5rk1/5ppp/8/8/8/4RB2/5PPP/6K1 w - - 0 1", solution: ["e3e8", "f8e8", "f3b7"], mateIn: 2 },
            // Queen sacrifices
            { id: "M2_021", fen: "r1bqr1k1/ppp2ppp/2np4/2bNp3/2B1P2Q/8/PPPP1PPP/RNB1K2R w KQ - 0 8", solution: ["h4h7", "g8h7", "d5f6"], mateIn: 2 },
            { id: "M2_022", fen: "r2qkb1r/ppp1pppp/2n2n2/3p2B1/3P4/2N2N2/PPP1PPPP/R2QKB1R w KQkq - 0 5", solution: ["g5f6", "e7f6", "d1h5"], mateIn: 2 },
            { id: "M2_023", fen: "rnbqk2r/pppp1Qpp/5n2/2b1p3/2B1P3/8/PPPP1PPP/RNB1K1NR b KQkq - 0 4", solution: ["e8f7", "c4g8", "f7g8"], mateIn: 2 },
            // Smothered mate setups
            { id: "M2_024", fen: "r4rk1/ppp1qppp/8/3pN3/3Pn3/8/PPP2PPP/R2Q1RK1 w - - 0 12", solution: ["d1h5", "g8h8", "e5f7"], mateIn: 2 },
            { id: "M2_025", fen: "r5k1/ppp2ppp/8/3pN2Q/3P4/8/PPP2PPP/6K1 w - - 0 1", solution: ["h5h7", "g8h7", "e5f7"], mateIn: 2 },
            // Arabian mate patterns
            { id: "M2_026", fen: "5rk1/5p1p/8/8/8/8/5P1P/4R1KN w - - 0 1", solution: ["e1e8", "f8e8", "h1f2"], mateIn: 2 },
            { id: "M2_027", fen: "6k1/5p1p/8/8/8/5N2/5P1P/4R1K1 w - - 0 1", solution: ["e1e8", "g8h7", "f3g5"], mateIn: 2 },
            // Opera mate patterns
            { id: "M2_028", fen: "1r2k3/8/8/8/8/4B3/8/R5K1 w - - 0 1", solution: ["a1a8", "b8a8", "e3b6"], mateIn: 2 },
            { id: "M2_029", fen: "r3k3/8/8/8/8/4B3/8/4R1K1 w - - 0 1", solution: ["e1e8", "a8e8", "e3a7"], mateIn: 2 },
            { id: "M2_030", fen: "2r1k3/8/8/8/8/4B3/8/R5K1 w - - 0 1", solution: ["a1a8", "c8a8", "e3b6"], mateIn: 2 },
            // Anastasia's mate
            { id: "M2_031", fen: "5rk1/4Nppp/8/8/Q7/8/5PPP/6K1 w - - 0 1", solution: ["a4h4", "g8h8", "h4h7"], mateIn: 2 },
            { id: "M2_032", fen: "5rk1/5ppp/4N3/8/7Q/8/5PPP/6K1 w - - 0 1", solution: ["h4h7", "g8h7", "e6f8"], mateIn: 2 },
            // Epaulette mate
            { id: "M2_033", fen: "3rkr2/8/8/8/8/8/4Q3/4K3 w - - 0 1", solution: ["e2e6", "e8d7", "e6d6"], mateIn: 2 },
            { id: "M2_034", fen: "3rkr2/8/4Q3/8/8/8/8/4K3 w - - 0 1", solution: ["e6d6", "e8e7", "d6d7"], mateIn: 2 },
            // Corridor mate
            { id: "M2_035", fen: "k7/2R5/1K6/8/8/8/8/8 w - - 0 1", solution: ["c7c8", "a8a7", "c8a8"], mateIn: 2 },
            { id: "M2_036", fen: "7k/5R2/6K1/8/8/8/8/8 w - - 0 1", solution: ["f7f8", "h8h7", "f8h8"], mateIn: 2 },
            // Hook mate
            { id: "M2_037", fen: "5k2/4N3/5K2/8/8/8/8/5R2 w - - 0 1", solution: ["f1f2", "f8e8", "f2f8"], mateIn: 2 },
            { id: "M2_038", fen: "3k4/8/2NK4/8/8/8/8/3R4 w - - 0 1", solution: ["d1d2", "d8c8", "d2d8"], mateIn: 2 },
            // Greco's mate
            { id: "M2_039", fen: "6k1/5ppp/8/8/8/6Q1/5P1P/6KR w - - 0 1", solution: ["h1h7", "g8h7", "g3g7"], mateIn: 2 },
            { id: "M2_040", fen: "6k1/5ppp/8/8/8/5Q2/5P1P/5RK1 w - - 0 1", solution: ["f1f7", "g8h8", "f3f8"], mateIn: 2 },
            // Boden's mate
            { id: "M2_041", fen: "2k5/ppp5/8/8/8/8/8/B3KB2 w - - 0 1", solution: ["a1e5", "c8d7", "f1a6"], mateIn: 2 },
            { id: "M2_042", fen: "2kr4/ppp5/8/8/5B2/8/8/B3K3 w - - 0 1", solution: ["f4d6", "c7d6", "a1e5"], mateIn: 2 },
            // Lolli's mate
            { id: "M2_043", fen: "6k1/5p1p/5Qp1/8/8/8/5PPP/6K1 w - - 0 1", solution: ["f6g7", "g8g7", "f2f4"], mateIn: 2 },
            { id: "M2_044", fen: "6k1/5ppp/4Q3/8/8/8/5PPP/6K1 w - - 0 1", solution: ["e6f7", "g8h8", "f7f8"], mateIn: 2 },
            // Damiano's mate
            { id: "M2_045", fen: "5k2/6R1/5K2/8/8/8/8/6Q1 w - - 0 1", solution: ["g1h2", "f8e8", "g7g8"], mateIn: 2 },
            { id: "M2_046", fen: "5k2/6R1/5K2/8/8/8/7Q/8 w - - 0 1", solution: ["h2h8", "f8e7", "g7g7"], mateIn: 2 },
            // Blackburne's mate
            { id: "M2_047", fen: "r1bqk2r/ppp2ppp/2n2n2/2bNp3/2B1P3/8/PPPP1PPP/RNBQK2R w KQkq - 0 5", solution: ["d5f6", "g7f6", "d1h5"], mateIn: 2 },
            { id: "M2_048", fen: "r1b1k2r/ppp1qppp/2n2n2/2bNp3/2B1P3/8/PPPP1PPP/RNBQK2R w KQkq - 0 6", solution: ["d5f6", "g7f6", "d1g4"], mateIn: 2 },
            // Corner mate with knight
            { id: "M2_049", fen: "7k/7p/5N2/8/8/8/6Q1/6K1 w - - 0 1", solution: ["g2g7", "h8g7", "f6h5"], mateIn: 2 },
            { id: "M2_050", fen: "7k/5N1p/8/8/8/8/6Q1/6K1 w - - 0 1", solution: ["g2g8", "h8g8", "f7h6"], mateIn: 2 },

            // === ADDITIONAL MATE IN 3 PUZZLES (from Lichess studies) ===
            { id: "M3_001", fen: "4k3/pp2P3/4K2p/2p5/3P4/5pp1/8/8 w - - 0 1", solution: ["d4d5", "f3f2", "d5d6", "f2f1q", "d6d7"], mateIn: 3 },
            { id: "M3_002", fen: "r3kb1r/pbqn1pp1/1p5p/2p1p3/4n2B/1QP5/PP1NBPPP/R3K1NR w - - 0 1", solution: ["b3e6", "f7e6", "h4h5", "g7g6", "h5g6"], mateIn: 3 },
            { id: "M3_003", fen: "r6k/1ppnNr1p/p4p1Q/2q2N2/2n2P2/4R3/PPP3PP/6K1 w - - 0 1", solution: ["f5g6", "h8g8", "h6g7", "f7g7", "e7h6"], mateIn: 3 },
            { id: "M3_004", fen: "3r4/pR2N3/2pkb3/5p2/8/2B5/qP3PPP/4R1K1 w - - 1 1", solution: ["c3e5", "d6c5", "e1c1", "e6c4", "b2b4"], mateIn: 3 },
            { id: "M3_005", fen: "k7/3B4/1K3B2/8/8/8/8/8 w - - 0 1", solution: ["f6a1", "a8b8", "d7e5", "b8a8", "a1c6"], mateIn: 3 },
            { id: "M3_006", fen: "5rk1/3bq1p1/1Q2p2p/3pP1n1/P2N4/2N5/1PP3PP/5RK1 b - - 0 23", solution: ["g5h3", "g2h3", "e7g5", "g1h1", "f8f1"], mateIn: 3 },
            { id: "M3_007", fen: "5q2/6k1/2p1bb1p/2n2B1Q/1N2pP2/1r2P3/1P5P/2B2KNR w - - 2 32", solution: ["h5h6", "g7g8", "h1h8", "g8h8", "h6h8"], mateIn: 3 },
            { id: "M3_008", fen: "r6k/4N3/2pq1b1p/2n2B2/4pP2/1r2P3/1P5P/2BQ1KNR b - - 2 32", solution: ["d6d1", "f1e2", "d1c2", "e2f3", "c2f2"], mateIn: 3 },
            { id: "M3_009", fen: "4r1k1/4r1p1/8/p2R1P1K/5P1P/1QP3q1/1P6/3R4 b - - 0 1", solution: ["g3g4", "h5h6", "g4h4", "h6g7", "e7h7"], mateIn: 3 },
            { id: "M3_010", fen: "r1bqk2r/2ppb1p1/n3P2p/8/2B1nP2/4P3/1PPP3P/RNBQK1NR w KQkq - 0 10", solution: ["d1h5", "g7g6", "h5h6", "e7g5", "h6h8"], mateIn: 3 },
            // Smothered mate sequences
            { id: "M3_011", fen: "r4rk1/ppp1qppp/8/3pN3/3Pn3/8/PPP2PPP/R2Q1RK1 w - - 0 12", solution: ["d1h5", "g8h8", "e5f7", "h8g8", "f7h6"], mateIn: 3 },
            { id: "M3_012", fen: "r4rk1/pppq1ppp/8/3pN3/3P4/8/PPP2PPP/R2Q1RK1 w - - 0 1", solution: ["e5f7", "f8f7", "d1h5", "g8f8", "h5f7"], mateIn: 3 },
            { id: "M3_013", fen: "r5k1/ppp1qppp/8/3pN3/3Pn3/8/PPP1QPPP/R4RK1 w - - 0 1", solution: ["e2h5", "g8h8", "e5f7", "h8g8", "f7h6"], mateIn: 3 },
            // King hunt patterns
            { id: "M3_014", fen: "r1bqkb1r/pppp1ppp/2n2n2/4p2Q/2B1P3/8/PPPP1PPP/RNB1K1NR w KQkq - 0 4", solution: ["h5f7", "e8e7", "c4c5", "e7e6", "f7f5"], mateIn: 3 },
            { id: "M3_015", fen: "r1bq1rk1/ppp2ppp/2np4/2bNp2n/2B1P3/3P4/PPP2PPP/R1BQ1RK1 w - - 0 9", solution: ["d5f6", "g7f6", "d1h5", "g8g7", "h5h7"], mateIn: 3 },
            // Queen and rook coordination
            { id: "M3_016", fen: "2rr2k1/5ppp/8/8/8/8/5PPP/1R1Q2K1 w - - 0 1", solution: ["d1d8", "c8d8", "b1b8", "d8b8", "b8b8"], mateIn: 3 },
            { id: "M3_017", fen: "3r2k1/5ppp/8/8/8/8/5PPP/2RQ2K1 w - - 0 1", solution: ["d1d8", "g8h7", "d8d1", "h7g8", "d1d8"], mateIn: 3 },
            // Bishop and queen mates
            { id: "M3_018", fen: "6k1/5ppp/8/8/8/4QB2/5PPP/6K1 w - - 0 1", solution: ["e3e8", "g8h7", "e8e4", "h7g8", "e4e8"], mateIn: 3 },
            { id: "M3_019", fen: "r4rk1/ppp2ppp/8/8/8/4QB2/5PPP/6K1 w - - 0 1", solution: ["e3e8", "f8e8", "f3b7", "a8b8", "b7a8"], mateIn: 3 },
            // Corridor mates extended
            { id: "M3_020", fen: "k7/8/1K6/8/8/8/8/7R w - - 0 1", solution: ["h1a1", "a8b8", "a1a8", "b8a8", "b6c7"], mateIn: 3 },
            { id: "M3_021", fen: "1k6/8/1K6/8/8/8/8/R7 w - - 0 1", solution: ["a1a8", "b8a8", "b6c6", "a8b8", "c6b6"], mateIn: 3 },
            // Double rook mates
            { id: "M3_022", fen: "6k1/5ppp/8/8/8/8/5PPP/RR4K1 w - - 0 1", solution: ["a1a8", "g8h7", "b1b7", "h7g6", "a8g8"], mateIn: 3 },
            { id: "M3_023", fen: "4r1k1/5ppp/8/8/8/8/5PPP/RR4K1 w - - 0 1", solution: ["b1b8", "e8b8", "a1b8", "g8h7", "b8b7"], mateIn: 3 },
            // Knight fork patterns into mate
            { id: "M3_024", fen: "r1bqk2r/pppp1ppp/2n2n2/2b1p3/2B1P3/5N2/PPPP1PPP/RNBQK2R w KQkq - 0 4", solution: ["f3g5", "d7d5", "g5f7", "e8f7", "d1h5"], mateIn: 3 },
            { id: "M3_025", fen: "r1bqk2r/pppp1Npp/2n2n2/2b1p3/2B1P3/8/PPPP1PPP/RNBQK2R b KQkq - 0 5", solution: ["d8e7", "f7d6", "e8d8", "c4f7", "c5d6"], mateIn: 3 },
            // Arabian mate extended
            { id: "M3_026", fen: "6k1/5p1p/8/8/8/5N2/5P1P/4R1K1 w - - 0 1", solution: ["e1e8", "g8h7", "e8e7", "h7g8", "f3h4"], mateIn: 3 },
            { id: "M3_027", fen: "5rk1/5p1p/8/8/8/5N2/5P1P/4R1K1 w - - 0 1", solution: ["e1e8", "f8e8", "f3g5", "g8f8", "g5h7"], mateIn: 3 },
            // Anastasia's mate sequences
            { id: "M3_028", fen: "r4rk1/ppp1Nppp/8/8/8/Q7/5PPP/6K1 w - - 0 1", solution: ["a3h3", "g8h8", "e7f5", "g7g6", "h3h6"], mateIn: 3 },
            { id: "M3_029", fen: "r4rk1/ppp2ppp/4N3/8/8/7Q/5PPP/6K1 w - - 0 1", solution: ["h3h6", "g8h8", "e6g5", "f8g8", "h6h7"], mateIn: 3 },
            // Mate with pawn promotion
            { id: "M3_030", fen: "8/5P1k/8/8/8/8/6K1/8 w - - 0 1", solution: ["f7f8q", "h7g6", "f8f3", "g6h5", "f3h3"], mateIn: 3 },
            { id: "M3_031", fen: "8/6Pk/8/8/8/8/6K1/8 w - - 0 1", solution: ["g7g8q", "h7h6", "g8g6", "h6h5", "g6g5"], mateIn: 3 },
            // Back rank extension
            { id: "M3_032", fen: "3r2k1/5ppp/8/8/8/8/5PPP/1R2R1K1 w - - 0 1", solution: ["b1b8", "d8b8", "e1e8", "b8e8", "e8e8"], mateIn: 3 },
            { id: "M3_033", fen: "r3r1k1/5ppp/8/8/8/8/5PPP/2RR2K1 w - - 0 1", solution: ["d1d8", "e8d8", "c1c8", "a8c8", "c8c8"], mateIn: 3 },
            // Queen chase
            { id: "M3_034", fen: "k7/8/1K3Q2/8/8/8/8/8 w - - 0 1", solution: ["f6a1", "a8b8", "a1h8", "b8a7", "h8a1"], mateIn: 3 },
            { id: "M3_035", fen: "k7/8/1KQ5/8/8/8/8/8 w - - 0 1", solution: ["c6c8", "a8a7", "c8b7", "a7a6", "b7b6"], mateIn: 3 },
            // Bishop pair extended
            { id: "M3_036", fen: "6k1/5p1p/8/8/8/1B2B3/5P1P/6K1 w - - 0 1", solution: ["b3e6", "g8h8", "e3c5", "h8g8", "e6f7"], mateIn: 3 },
            { id: "M3_037", fen: "5k2/5p1p/8/8/8/1B2B3/5P1P/6K1 w - - 0 1", solution: ["b3c4", "f8e8", "e3a7", "e8d8", "a7c5"], mateIn: 3 },
            // Heavy piece coordination
            { id: "M3_038", fen: "6k1/5ppp/8/8/8/8/5PPP/3QR1K1 w - - 0 1", solution: ["e1e8", "g8h7", "d1d3", "h7g6", "d3g3"], mateIn: 3 },
            { id: "M3_039", fen: "4r1k1/5ppp/8/8/8/8/5PPP/3QR1K1 w - - 0 1", solution: ["d1d8", "e8d8", "e1e8", "g8h7", "e8d8"], mateIn: 3 },
            // Mating nets
            { id: "M3_040", fen: "5rk1/5ppp/8/8/8/3B4/5PPP/3R2K1 w - - 0 1", solution: ["d3h7", "g8h7", "d1d7", "h7g8", "d7g7"], mateIn: 3 },
            { id: "M3_041", fen: "3r2k1/5ppp/8/8/8/3B4/5PPP/3R2K1 w - - 0 1", solution: ["d1d8", "g8h7", "d3f5", "g7g6", "d8h8"], mateIn: 3 },
            // Queen and knight combos
            { id: "M3_042", fen: "6k1/5ppp/4N3/8/8/8/5PPP/3Q2K1 w - - 0 1", solution: ["d1d8", "g8h7", "e6f8", "h7h6", "d8h4"], mateIn: 3 },
            { id: "M3_043", fen: "r4rk1/5ppp/8/4N3/8/8/5PPP/3Q2K1 w - - 0 1", solution: ["d1d7", "f8f7", "e5f7", "g8h8", "d7d8"], mateIn: 3 },
            // Clearance sacrifices
            { id: "M3_044", fen: "r4rk1/ppp2ppp/8/8/3NP3/8/PPP2PPP/R4RK1 w - - 0 1", solution: ["d4f5", "g8h8", "f5h6", "g7h6", "f1f8"], mateIn: 3 },
            { id: "M3_045", fen: "r4rk1/ppp2ppp/8/8/4N3/8/PPP2PPP/R4RK1 w - - 0 1", solution: ["e4f6", "g7f6", "f1f6", "g8h8", "a1a8"], mateIn: 3 },
            // King walk mates
            { id: "M3_046", fen: "8/8/8/8/8/4k3/4P3/4K2R w - - 0 1", solution: ["h1h3", "e3f4", "h3h4", "f4f5", "h4h5"], mateIn: 3 },
            { id: "M3_047", fen: "8/8/8/8/5k2/8/5P2/5K1R w - - 0 1", solution: ["h1h4", "f4f5", "h4h5", "f5f6", "h5h6"], mateIn: 3 },
            // Rook lift mates
            { id: "M3_048", fen: "r4rk1/6pp/8/8/8/8/R5PP/5RK1 w - - 0 1", solution: ["a2a8", "f8a8", "f1f8", "a8f8", "f8f8"], mateIn: 3 },
            { id: "M3_049", fen: "2r3k1/6pp/8/8/8/8/R5PP/4R1K1 w - - 0 1", solution: ["a2a8", "c8a8", "e1e8", "a8e8", "e8e8"], mateIn: 3 },
            { id: "M3_050", fen: "5rk1/6pp/8/8/8/2R5/6PP/5RK1 w - - 0 1", solution: ["c3c8", "f8c8", "f1f8", "c8f8", "f8f8"], mateIn: 3 },
        ];

        // DOM Elements
        const setupScreen = document.getElementById('setup-screen');
        const gameLayout = document.getElementById('game-layout');
        const statusBar = document.getElementById('status-bar');
        const gameControls = document.getElementById('game-controls');
        const puzzleControls = document.getElementById('puzzle-controls');
        const difficultySection = document.getElementById('difficulty-section');
        const colorSection = document.getElementById('color-section');
        const boardEl = document.getElementById('board');
        const moveListEl = document.getElementById('move-list');
        const moveTextEl = document.getElementById('move-text');
        const moveErrorEl = document.getElementById('move-error');
        const gameStatusEl = document.getElementById('game-status');
        const gameOverModal = document.getElementById('game-over-modal');
        const gameOverMessage = document.getElementById('game-over-message');

        // Setup screen button handlers
        document.querySelectorAll('.mode-buttons .setup-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.mode-buttons .setup-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                gameMode = btn.dataset.mode;
                // Show/hide difficulty and color sections based on mode
                if (gameMode === 'ai') {
                    difficultySection.style.display = 'block';
                    colorSection.style.display = 'block';
                } else {
                    difficultySection.style.display = 'none';
                    colorSection.style.display = 'none';
                }
            };
        });

        document.querySelectorAll('.difficulty-buttons .setup-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.difficulty-buttons .setup-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                skillLevel = parseInt(btn.dataset.level);
                thinkTime = parseInt(btn.dataset.time);
            };
        });

        document.querySelectorAll('.color-buttons .setup-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.color-buttons .setup-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                playerColor = btn.dataset.color;
            };
        });

        document.getElementById('start-game').onclick = startGame;
        document.getElementById('new-game-btn').onclick = showSetupScreen;
        document.getElementById('play-again-btn').onclick = () => {
            gameOverModal.classList.remove('active');
            showSetupScreen();
        };
        document.getElementById('submit-move').onclick = submitTextMove;
        document.getElementById('undo-btn').onclick = undoMove;
        document.getElementById('resign-btn').onclick = resignGame;

        // Puzzle controls
        document.getElementById('next-puzzle-btn').onclick = nextPuzzle;
        document.getElementById('retry-puzzle-btn').onclick = retryPuzzle;
        document.getElementById('show-solution-btn').onclick = showSolution;
        document.getElementById('back-to-menu-btn').onclick = showSetupScreen;

        moveTextEl.onkeyup = (e) => {
            if (e.key === 'Enter') submitTextMove();
        };

        function showSetupScreen() {
            setupScreen.style.display = 'block';
            gameLayout.classList.remove('active');
            statusBar.style.display = 'none';
            gameControls.style.display = 'none';
            puzzleControls.style.display = 'none';
            // Reset mode display
            if (gameMode === 'ai') {
                difficultySection.style.display = 'block';
                colorSection.style.display = 'block';
            } else {
                difficultySection.style.display = 'none';
                colorSection.style.display = 'none';
            }
        }

        function startGame() {
            if (gameMode === 'ai') {
                startAIGame();
            } else if (gameMode === 'puzzles') {
                startPuzzle();
            }
        }

        function startAIGame() {
            // Handle random color
            if (playerColor === 'random') {
                playerColor = Math.random() < 0.5 ? 'w' : 'b';
            }

            // Initialize chess.js
            game = new Chess();
            selectedSquare = null;
            capturedPieces = { w: [], b: [] };
            lastMove = null;
            gameOver = false;

            // Switch to game view
            setupScreen.style.display = 'none';
            gameLayout.classList.add('active');
            statusBar.style.display = 'flex';
            gameControls.style.display = 'flex';
            puzzleControls.style.display = 'none';

            // Clear move list
            moveListEl.innerHTML = '';
            moveErrorEl.textContent = '';
            moveTextEl.value = '';

            // Update captured pieces display
            document.getElementById('captured-white').textContent = '';
            document.getElementById('captured-black').textContent = '';

            // Create board and render
            createBoard();
            renderPosition();
            updateStatus();

            // Initialize Stockfish if not already done
            if (!stockfish) {
                initStockfish();
            } else if (stockfishReady) {
                setSkillLevel(skillLevel);
                // If player is black, AI moves first
                if (playerColor === 'b') {
                    setTimeout(makeAIMove, 500);
                }
            }
        }

        function startPuzzle() {
            // Pick a random puzzle
            puzzleIndex = Math.floor(Math.random() * MATING_PUZZLES.length);
            currentPuzzle = MATING_PUZZLES[puzzleIndex];
            puzzleMoveIndex = 0;
            puzzleSolved = false;
            gameOver = false;
            selectedSquare = null;
            lastMove = null;

            // Load puzzle position
            game = new Chess(currentPuzzle.fen);

            // Check if puzzle has setup move (old format) or direct solution (new format)
            if (currentPuzzle.solution) {
                // New format: FEN is the starting position, solution is the moves
                puzzleSolution = currentPuzzle.solution;
                lastMove = null;
            } else {
                // Old format: play the setup move first
                const setupMove = currentPuzzle.moves[0];
                const from = setupMove.substring(0, 2);
                const to = setupMove.substring(2, 4);
                const promotion = setupMove[4];
                const setupMoveObj = game.move({ from, to, promotion });
                if (setupMoveObj) {
                    lastMove = setupMoveObj;
                }
                puzzleSolution = currentPuzzle.moves.slice(1);
            }

            // Player plays as the side to move
            playerColor = game.turn();

            // Switch to game view
            setupScreen.style.display = 'none';
            gameLayout.classList.add('active');
            statusBar.style.display = 'flex';
            gameControls.style.display = 'none';
            puzzleControls.style.display = 'flex';

            // Clear move list
            moveListEl.innerHTML = '';
            moveErrorEl.textContent = '';
            moveTextEl.value = '';

            // Update captured pieces display
            document.getElementById('captured-white').textContent = '';
            document.getElementById('captured-black').textContent = '';

            // Create board and render
            createBoard();
            renderPosition();

            const mateLabel = currentPuzzle.mateIn === 2 ? 'Mate in 2' : 'Mate in 3';
            showStatus(`${mateLabel} - Find the winning move!`);
        }

        function nextPuzzle() {
            // Pick a new random puzzle (avoid repeating the same one)
            let newIndex;
            do {
                newIndex = Math.floor(Math.random() * MATING_PUZZLES.length);
            } while (newIndex === puzzleIndex && MATING_PUZZLES.length > 1);
            puzzleIndex = newIndex;
            startPuzzle();
        }

        function retryPuzzle() {
            startPuzzle();
        }

        function showSolution() {
            if (!currentPuzzle) return;

            // Reset to puzzle start
            game = new Chess(currentPuzzle.fen);

            // Check format and setup accordingly
            if (currentPuzzle.solution) {
                // New format: no setup move
                puzzleSolution = currentPuzzle.solution;
                lastMove = null;
            } else {
                // Old format: play setup move first
                const setupMove = currentPuzzle.moves[0];
                const setupFrom = setupMove.substring(0, 2);
                const setupTo = setupMove.substring(2, 4);
                const setupPromotion = setupMove[4];
                const setupMoveObj = game.move({ from: setupFrom, to: setupTo, promotion: setupPromotion });
                if (setupMoveObj) {
                    lastMove = setupMoveObj;
                }
                puzzleSolution = currentPuzzle.moves.slice(1);
            }

            playerColor = game.turn();
            puzzleMoveIndex = 0;
            puzzleSolved = true;
            gameOver = true;

            // Play solution moves with animation
            let moveIdx = 0;
            const playNextMove = () => {
                if (moveIdx >= puzzleSolution.length) {
                    showStatus('Solution complete!');
                    gameStatusEl.classList.add('correct');
                    return;
                }

                const uciMove = puzzleSolution[moveIdx];
                const from = uciMove.substring(0, 2);
                const to = uciMove.substring(2, 4);
                const promotion = uciMove[4];

                const move = game.move({ from, to, promotion });
                if (move) {
                    lastMove = move;
                    renderPosition();
                    updateMoveList(move);
                }

                moveIdx++;
                setTimeout(playNextMove, 800);
            };

            createBoard();
            renderPosition();
            moveListEl.innerHTML = '';
            setTimeout(playNextMove, 500);
        }

        function handlePuzzleMove(move) {
            const expectedUci = puzzleSolution[puzzleMoveIndex];
            const playerUci = move.from + move.to + (move.promotion || '');

            if (playerUci === expectedUci) {
                // Correct move!
                puzzleMoveIndex++;
                lastMove = move;
                renderPosition();
                updateMoveList(move);

                // Check if puzzle is complete
                if (puzzleMoveIndex >= puzzleSolution.length) {
                    puzzleSolved = true;
                    gameOver = true;
                    showStatus('Correct! Puzzle solved!');
                    gameStatusEl.classList.remove('wrong');
                    gameStatusEl.classList.add('correct');
                    return;
                }

                // Make opponent's response after a short delay
                setTimeout(() => {
                    const responseUci = puzzleSolution[puzzleMoveIndex];
                    const from = responseUci.substring(0, 2);
                    const to = responseUci.substring(2, 4);
                    const promotion = responseUci[4];

                    const responseMove = game.move({ from, to, promotion });
                    if (responseMove) {
                        puzzleMoveIndex++;
                        lastMove = responseMove;
                        renderPosition();
                        updateMoveList(responseMove);

                        if (puzzleMoveIndex >= puzzleSolution.length) {
                            puzzleSolved = true;
                            gameOver = true;
                            showStatus('Correct! Puzzle solved!');
                            gameStatusEl.classList.add('correct');
                        } else {
                            showStatus('Correct! Keep going...');
                            gameStatusEl.classList.remove('wrong');
                            gameStatusEl.classList.add('correct');
                            setTimeout(() => {
                                gameStatusEl.classList.remove('correct');
                                showStatus('Find the next move!');
                            }, 1000);
                        }
                    }
                }, 400);
            } else {
                // Wrong move - undo it
                game.undo();
                showStatus('Not quite - try again!');
                gameStatusEl.classList.remove('correct');
                gameStatusEl.classList.add('wrong');
                setTimeout(() => {
                    gameStatusEl.classList.remove('wrong');
                    showStatus('Find the winning move!');
                }, 1500);
            }
        }

        function createBoard() {
            boardEl.innerHTML = '';

            // Determine board orientation
            const isFlipped = playerColor === 'b';
            const ranks = isFlipped ? [1,2,3,4,5,6,7,8] : [8,7,6,5,4,3,2,1];
            const files = isFlipped ? [7,6,5,4,3,2,1,0] : [0,1,2,3,4,5,6,7];

            // Update labels for board orientation
            const fileLabels = isFlipped ? 'hgfedcba' : 'abcdefgh';
            const rankLabels = isFlipped ? '12345678' : '87654321';

            document.querySelectorAll('.file-labels').forEach(el => {
                el.innerHTML = fileLabels.split('').map(f => `<span>${f}</span>`).join('');
            });
            document.getElementById('rank-labels').innerHTML =
                rankLabels.split('').map(r => `<span>${r}</span>`).join('');

            for (let rankIdx = 0; rankIdx < 8; rankIdx++) {
                for (let fileIdx = 0; fileIdx < 8; fileIdx++) {
                    const rank = ranks[rankIdx];
                    const file = files[fileIdx];
                    const squareName = String.fromCharCode(97 + file) + rank;
                    const isLight = (rank + file) % 2 === 1;

                    const square = document.createElement('div');
                    square.className = `square ${isLight ? 'light' : 'dark'}`;
                    square.dataset.square = squareName;
                    square.onclick = () => handleSquareClick(squareName);

                    boardEl.appendChild(square);
                }
            }
        }

        function renderPosition() {
            const position = game.board();

            document.querySelectorAll('.square').forEach(squareEl => {
                const squareName = squareEl.dataset.square;
                const file = squareName.charCodeAt(0) - 97;
                const rank = parseInt(squareName[1]) - 1;

                const piece = position[7 - rank][file];

                // Clear previous content
                squareEl.textContent = '';
                squareEl.classList.remove('white-piece', 'black-piece', 'piece-p', 'piece-b', 'piece-n', 'piece-r', 'piece-q', 'piece-k');

                if (piece) {
                    const symbol = piece.color === 'w'
                        ? PIECES[piece.type.toUpperCase()]
                        : PIECES[piece.type];
                    squareEl.textContent = symbol;
                    squareEl.classList.add(piece.color === 'w' ? 'white-piece' : 'black-piece');
                    squareEl.classList.add('piece-' + piece.type);
                }
            });

            // Highlight last move
            highlightLastMove();

            // Highlight check
            highlightCheck();
        }

        function highlightLastMove() {
            document.querySelectorAll('.last-move-from, .last-move-to').forEach(el => {
                el.classList.remove('last-move-from', 'last-move-to');
            });

            if (lastMove) {
                const fromEl = document.querySelector(`[data-square="${lastMove.from}"]`);
                const toEl = document.querySelector(`[data-square="${lastMove.to}"]`);
                if (fromEl) fromEl.classList.add('last-move-from');
                if (toEl) toEl.classList.add('last-move-to');
            }
        }

        function highlightCheck() {
            document.querySelectorAll('.check').forEach(el => el.classList.remove('check'));

            if (game.in_check()) {
                // Find the king that's in check
                const turn = game.turn();
                const position = game.board();

                for (let rank = 0; rank < 8; rank++) {
                    for (let file = 0; file < 8; file++) {
                        const piece = position[rank][file];
                        if (piece && piece.type === 'k' && piece.color === turn) {
                            const squareName = String.fromCharCode(97 + file) + (8 - rank);
                            const squareEl = document.querySelector(`[data-square="${squareName}"]`);
                            if (squareEl) squareEl.classList.add('check');
                            return;
                        }
                    }
                }
            }
        }

        function handleSquareClick(square) {
            if (gameOver || !isPlayerTurn()) return;

            const piece = game.get(square);

            if (selectedSquare) {
                // Second click - try to move
                const move = tryMove(selectedSquare, square);
                if (move) {
                    clearHighlights();
                    afterPlayerMove(move);
                } else if (piece && piece.color === playerColor) {
                    // Clicked own piece - select it instead
                    selectSquare(square);
                } else {
                    // Invalid move
                    clearHighlights();
                    selectedSquare = null;
                }
            } else {
                // First click - select piece
                if (piece && piece.color === playerColor) {
                    selectSquare(square);
                }
            }
        }

        function selectSquare(square) {
            clearHighlights();
            selectedSquare = square;

            const squareEl = document.querySelector(`[data-square="${square}"]`);
            squareEl.classList.add('selected');
        }

        function clearHighlights() {
            document.querySelectorAll('.selected, .legal-move, .legal-capture').forEach(el => {
                el.classList.remove('selected', 'legal-move', 'legal-capture');
            });
            selectedSquare = null;
        }

        function tryMove(from, to) {
            // Check for pawn promotion
            const piece = game.get(from);
            const isPromotion = piece && piece.type === 'p' &&
                ((piece.color === 'w' && to[1] === '8') ||
                 (piece.color === 'b' && to[1] === '1'));

            const moveObj = {
                from: from,
                to: to,
                promotion: isPromotion ? 'q' : undefined  // Auto-queen
            };

            return game.move(moveObj);
        }

        function submitTextMove() {
            if (gameOver || !isPlayerTurn()) return;

            const moveText = moveTextEl.value.trim();
            if (!moveText) return;

            // chess.js accepts SAN notation
            const move = game.move(moveText);

            if (move) {
                moveErrorEl.textContent = '';
                moveTextEl.value = '';
                clearHighlights();
                afterPlayerMove(move);
            } else {
                moveErrorEl.textContent = `Invalid: "${moveText}"`;
            }
        }

        function afterPlayerMove(move) {
            if (gameMode !== 'ai') {
                // Puzzle mode - check if move is correct
                handlePuzzleMove(move);
                return;
            }

            lastMove = move;
            updateCaptured(move);
            renderPosition();
            updateMoveList(move);
            updateStatus();

            if (game.game_over()) {
                handleGameOver();
            } else {
                // AI's turn
                setTimeout(makeAIMove, 300);
            }
        }

        function isPlayerTurn() {
            return game.turn() === playerColor;
        }

        function updateStatus() {
            gameStatusEl.classList.remove('thinking', 'check', 'game-over');

            if (gameOver) {
                return;
            }

            if (game.in_check()) {
                gameStatusEl.textContent = isPlayerTurn() ? 'Check! Your turn' : 'Check!';
                gameStatusEl.classList.add('check');
            } else if (isPlayerTurn()) {
                gameStatusEl.textContent = 'Your turn';
            } else {
                gameStatusEl.textContent = 'Thinking...';
                gameStatusEl.classList.add('thinking');
            }
        }

        function updateCaptured(move) {
            if (move.captured) {
                const capturedColor = move.color === 'w' ? 'b' : 'w';
                capturedPieces[capturedColor].push(move.captured);
                renderCaptured();
            }
        }

        function renderCaptured() {
            const order = ['q', 'r', 'b', 'n', 'p'];

            const whiteCaptured = [...capturedPieces.w].sort((a, b) => order.indexOf(a) - order.indexOf(b));
            const blackCaptured = [...capturedPieces.b].sort((a, b) => order.indexOf(a) - order.indexOf(b));

            document.getElementById('captured-white').textContent =
                whiteCaptured.map(p => PIECES[p.toUpperCase()]).join('');
            document.getElementById('captured-black').textContent =
                blackCaptured.map(p => PIECES[p]).join('');
        }

        function updateMoveList(move) {
            const history = game.history();
            const moveNum = Math.ceil(history.length / 2);
            const isWhiteMove = history.length % 2 === 1;

            if (isWhiteMove) {
                const row = document.createElement('div');
                row.className = 'move-row';
                row.innerHTML = `
                    <span class="move-num">${moveNum}.</span>
                    <span class="white-move">${move.san}</span>
                    <span class="black-move"></span>
                `;
                moveListEl.appendChild(row);
            } else {
                const lastRow = moveListEl.lastElementChild;
                if (lastRow) {
                    lastRow.querySelector('.black-move').textContent = move.san;
                }
            }

            moveListEl.scrollTop = moveListEl.scrollHeight;
        }

        function rebuildMoveList() {
            moveListEl.innerHTML = '';
            const history = game.history();

            for (let i = 0; i < history.length; i += 2) {
                const moveNum = Math.floor(i / 2) + 1;
                const row = document.createElement('div');
                row.className = 'move-row';
                row.innerHTML = `
                    <span class="move-num">${moveNum}.</span>
                    <span class="white-move">${history[i]}</span>
                    <span class="black-move">${history[i + 1] || ''}</span>
                `;
                moveListEl.appendChild(row);
            }
        }

        function undoMove() {
            if (gameOver || game.history().length < 2) return;

            // Undo AI move and player move
            const undone1 = game.undo();
            const undone2 = game.undo();

            // Restore captured pieces
            if (undone1 && undone1.captured) {
                const color = undone1.color === 'w' ? 'b' : 'w';
                const idx = capturedPieces[color].lastIndexOf(undone1.captured);
                if (idx > -1) capturedPieces[color].splice(idx, 1);
            }
            if (undone2 && undone2.captured) {
                const color = undone2.color === 'w' ? 'b' : 'w';
                const idx = capturedPieces[color].lastIndexOf(undone2.captured);
                if (idx > -1) capturedPieces[color].splice(idx, 1);
            }

            // Update last move
            const history = game.history({ verbose: true });
            lastMove = history.length > 0 ? history[history.length - 1] : null;

            renderCaptured();
            renderPosition();
            rebuildMoveList();
            updateStatus();
        }

        function resignGame() {
            if (gameOver) return;
            if (confirm('Are you sure you want to resign?')) {
                gameOver = true;
                showGameOver('You resigned');
            }
        }

        function handleGameOver() {
            gameOver = true;
            let message = '';

            if (game.in_checkmate()) {
                const winner = game.turn() === 'w' ? 'Black' : 'White';
                const playerWon = (winner === 'White' && playerColor === 'w') ||
                                 (winner === 'Black' && playerColor === 'b');
                message = playerWon ? 'Checkmate! You win!' : 'Checkmate! You lose!';
            } else if (game.in_stalemate()) {
                message = 'Stalemate! Draw.';
            } else if (game.in_threefold_repetition()) {
                message = 'Threefold repetition! Draw.';
            } else if (game.insufficient_material()) {
                message = 'Insufficient material! Draw.';
            } else if (game.in_draw()) {
                message = 'Draw!';
            }

            showGameOver(message);
        }

        function showGameOver(message) {
            gameStatusEl.textContent = message;
            gameStatusEl.classList.add('game-over');
            gameOverMessage.textContent = message;
            gameOverModal.classList.add('active');
        }

        // ============ STOCKFISH ============

        function initStockfish() {
            showStatus('Loading engine...');

            // Try to load Stockfish
            try {
                stockfish = new Worker('js/stockfish.min.js');

                stockfish.onmessage = (event) => {
                    const line = event.data;

                    if (line === 'uciok') {
                        stockfish.postMessage('isready');
                    } else if (line === 'readyok') {
                        stockfishReady = true;
                        setSkillLevel(skillLevel);
                        updateStatus();

                        // If player is black, AI moves first
                        if (playerColor === 'b' && !gameOver) {
                            setTimeout(makeAIMove, 500);
                        }
                    } else if (line.startsWith('bestmove')) {
                        handleStockfishMove(line);
                    }
                };

                stockfish.onerror = (err) => {
                    console.error('Stockfish error:', err);
                    stockfishReady = false;
                    showStatus('Engine error - reload page');
                };

                stockfish.postMessage('uci');
            } catch (err) {
                console.error('Failed to load Stockfish:', err);
                showStatus('Engine not available');
            }
        }

        function setSkillLevel(level) {
            if (stockfish && stockfishReady) {
                stockfish.postMessage('setoption name Skill Level value ' + level);
            }
        }

        function showStatus(msg) {
            gameStatusEl.textContent = msg;
        }

        function makeAIMove() {
            if (gameOver || !stockfishReady || isPlayerTurn()) return;

            updateStatus();

            const fen = game.fen();
            stockfish.postMessage('position fen ' + fen);

            // Think time based on difficulty
            const thinkTime = getThinkTime(skillLevel);
            stockfish.postMessage(`go movetime ${thinkTime}`);
        }

        function getThinkTime(level) {
            // Use the stored thinkTime from difficulty selection
            return thinkTime;
        }

        function handleStockfishMove(line) {
            const parts = line.split(' ');
            const moveStr = parts[1];

            if (!moveStr || moveStr === '(none)') {
                handleGameOver();
                return;
            }

            // Parse Stockfish format (e2e4, e7e8q for promotion)
            const from = moveStr.substring(0, 2);
            const to = moveStr.substring(2, 4);
            const promotion = moveStr[4];

            const move = game.move({
                from: from,
                to: to,
                promotion: promotion || undefined
            });

            if (move) {
                lastMove = move;
                updateCaptured(move);
                renderPosition();
                updateMoveList(move);

                if (game.game_over()) {
                    handleGameOver();
                } else {
                    updateStatus();
                }
            }
        }
    </script>
    <script type="module" src="js/analytics.js"></script>
</body>
</html>
